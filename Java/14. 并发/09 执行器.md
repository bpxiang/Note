# 执行器
>time: 2018-08-14 15:30:42

构建一个新的线程是有一定代价的，因为涉及与操作系统的交互。如果程序中创建了大量的生命期很短的线程，应该使用线程池（thread pool）。一个线程池中包含许多准备运行的空闲线程。将 Runnable 对象交给线程池，就会有一个线程调用 run 方法。当 run 方法退出时，线程不会死亡，而是在线程池中准备为下一个请求提供服务。

另一个使用线程池的理由是减少并发线程的数目。创建大量线程会大大降低性能甚至使虚拟机崩溃。如果有一个会创建许多线程的算法，应该使用一个线程数“固定的”线程池以限制并发线程的总数。

执行器（Executor）类有许多静态工厂方法用来构建线程池。

#### 执行者工程方法
| 方法 | 描述 |
|---|---|
| newCachedThreadPool | 必要时创建新线程；空闲线程会被保留 60 秒 |
| newFixedThreadPool | 线程包含固定数量的线程；空闲线程会一直被保留 |
| newSingleThreadExecutor | 只有一个线程的“池”，该线程顺序执行每一行提交的任务（类似于 Swing 事件分配线程） |
| newScheduledThreadPool | 用于预定执行而构建的固定线程池，替代 java.util.Time |
| newSingleThreadScheduledExecutor | 用于预定执行而构建的单线程“池” |

# 1. 线程池

1. newCachedThreadPool: 构建一个线程池，对于每个任务，如果有空闲线程可用，立即让它执行任务，如果没有可用的空闲线程，则创建一个新线程。
2. newFixedThreadPool: 构建一个具有固定大小的线程池。如果提交的任务数多于空闲的线程数。那么把得不到的服务放置到队列中。当其他任务完成以后再运行它们。
3. newSingleThreadExecutor: 是一个退化了的大小为 1 的线程池： 由一个线程执行提交的任务，一个接着一个。

以上 3 个方法返回实现了 ExecutorService 接口的 ThreadPoolExecutor 类的对象。  
可用下面方法之一将一个 Runnable 对象或 Callable 对象提交给 ExecutorService
```java
Future<?> submit(Runnable task)
Future<T> submit(Runnable task, T result)
Futrue<T> submit(Callable<T> task)
```
该池会在方便的时候尽早执行提交的任务。调用 submit 时，会得到一个 Future 对象，可用来查询该任务的状态。

第一个 submit 方法返回一个奇怪样子的 `Future<?>`。可以使用这样一个对象调用 isDone、cancel 或 isCancelled。但是，get 方法在完成的时候只是简单地返回 null。  
第二个版本的 submit 也提交了一个 Runnable，并且 Future 的 get 方法在完成的时候返回指定的 result 对象。  
第三个版本的 submit 提交了一个 Callable，并且返回的 Future 对象将在计算结果准备好的时候得到它。

当用完一个线程池的时候，调用 shutdown。该方法启动该池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成以后，线程池中的线程死亡。另一种方法是盗用 shutdownNow。该池取消尚未开始的所有任务并试图中断正在运行的线程。

使用连接池时应该做的事：
1. 调用 Executor 类中静态的方法 newCachedThreadPool 或 newFixedThreadPool。
2. 调用 submit 提交 Runnable 或 Callable 对象。
3. 如果想要取消一个任务，或如果提交 Callable 对象，那就要保存好返回的 Future 对象。
4. 当不再提交任何任务时，调用 shutdown。

```java
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadPoolExecutor;

public class ThreadPoolTest {

    public static void main(String[] args) {
        try (Scanner in = new Scanner(System.in)) {
            System.out.println("Enter base directory (e.g. /usr/local/jdk5.0/src): ");
            String directory = in.nextLine();
            System.out.println("Enter keyword (e.g. volatile): ");
            String keyword = in.nextLine();
            
            ExecutorService pool = Executors.newCachedThreadPool();
            
            MatchCounter counter = new MatchCounter(new File(directory), keyword, pool);
            Future<Integer> result = pool.submit(counter);
            
            try {
                System.out.println(result.get() + " matching files.");
            }catch(ExecutionException e) {
                e.printStackTrace();
            } catch (InterruptedException e) {
            }
            pool.shutdown();
            
            int largestPoolSize = ((ThreadPoolExecutor) pool).getLargestPoolSize();
            System.out.println("largest pool size=" + largestPoolSize);
        }
    }
}
class MatchCounter implements Callable<Integer> {
    private File directory;
    private String keyword;
    private ExecutorService pool;
    private int count;
    
    public MatchCounter(File directory, String keyword, ExecutorService pool) {
        this.directory = directory;
        this.keyword = keyword;
        this.pool = pool;
    }
    @Override
    public Integer call() {
        int count = 0;
        try {
            File[] files = directory.listFiles();
            List<Future<Integer>> results = new ArrayList<>();
            
            for (File file : files) {
                if (file.isDirectory()) {
                    MatchCounter counter = new MatchCounter(file, keyword, pool);
                    Future<Integer> result = pool.submit(counter);
                    results.add(result);
                }else {
                    if (search(file)) count++;
                }
            }
            
            for(Future<Integer> result: results) {
                try {
                    count += result.get();
                }catch(ExecutionException e) {
                    e.printStackTrace();
                }               
            }
        } catch (InterruptedException e) {}
        
        return count;
    }
    
    public boolean search(File file) {
        try {
            try(Scanner in = new Scanner(file, "UTF-8")) {
                boolean found = false;
                while(!found && in.hasNextLine()) {
                    String line = in.nextLine();
                    if (line.contains(keyword)) {
                        found = true;
                    }
                }
                return found;
            }
        }catch(IOException e) {
            return false;
        }
    }
    
}
```


