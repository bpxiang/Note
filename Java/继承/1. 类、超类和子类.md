# 类、超类和子类
>time: 2017-12-18 16:58:12

 “is-a” 关系是继承的一个明显特征。

## 1. 定义子类

关键字 extends 表示继承。
```java
public class Manager extends Employee
{
    ...
}
```
在 Java 中，所有的继承都是公有继承。

关键字 extends 表明正在构造的新类派生于一个已存在的类。已存在的类称为超类（superclass）、基类（base class）或父类（parent class）；新类称为子类（subclass）、派生类（derived class）或孩子类（child class）。超类和子类是 Java 程序员最常用的两个术语，而了解其他语言的程序员可能更加偏爱使用父类和孩子类，这些都是继承时使用得术语。

尽管 Employee 类是一个超类，但并不是因为它优于子类或者拥有比子类更多的功能。实际上恰恰相反 ，子类比超类拥有的功能更加丰富。例如，读过 Manager 类的源代码之后就会发现， Manager 类比超类 Employee 封装了更多的数据，拥有更多的功能。

注释： 前缀 “超” 和 “子” 来源于计算机科学和数学理论中的集合语言的术语。所有雇员组成的集合包含所有经理组成的集合。可以这样说，雇员集合是经理集合的超集，也可以说， 经理集合是雇员集合的子集。

在 Manager 类中 ，增加了一个用于存储奖金信息的域 ，以及一个用于设置这个域的新方法 ：
```java
public class Manager extends Employee
{
    private double bonus;
    ...
    public void setBonus(double bonus)
    {
        this.bonus = bonus;
    }
}
```

这里定义的方法和域并没有什么特别之处。如果有一个 Manager 对象，就可以使用 setBonus 方法。
```java
Manager boss = ...;
boss.setBonus(5000);
```

当然，由于 setBonus 方法不是在 Employee 类中定义的 ， 所以属于 Employee 类的对象不能使用它。

然而， 尽管在 Manager 类中没有显式地定义 getName 和 getHireDay 等方法， 但属于Manager 类的对象却可以使用它们 ， 这是因为 Manager 类自动地继承了超类 Employee 中的这些方法。

同样，从超类中还继承了 name、 salary 和 hireDay 这 3 个域。这样一来， 每个 Manager 类对象就包含了 4个域： name、 salary 、 hireDay 和 bonus。

在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中，这种将通用的功能放到超类的做法，在面向对象程序设计中十分普遍。

## 2. 覆盖方法
子类的方法不能直接访问超类的私有域。如果一定要访问私有域，就必须借助于公有的接口，使用特定的关键字 super。

```java
public double getSalary() {
    double baseSalary = super.getSalary();
    return baseSalay + bonus;
}
```

注释：有些人认为 super 与 this 引用是类似的概念，实际上，这样比较并不恰当。这是因为 super 不是一个对象的引用，不能讲 super 赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。

## 3. 子类构造器
```java
public Manager(String name, double salary, int year, int month, int day)
{
    super(name, salary, year, month, day);
    bonus = 0;
}
```
这里的关键字 super 具有不同的含义。语句
```java
super(n, s, year, month, day);
```
是“ 调用超类中含有 n、 s、year month和 day参数的构造器” 的简写形式。

如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数 )的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类
的其他构造器，则 Java 编译器将报告错误。

### this有两个用途
* 引用隐式参数
* 调用该类其他的构造器

### super 关键字也有两个用途
* 调用超类的方法
* 调用超类的构造器

一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。

在 Java 中，不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征，可以将它标记为 final。

## 4. 继承层次

继承并不仅限于一个层次。由一个公共超类派生出来的所有类的集合被称为继承层次（inheritance hierarchy），在继承层次中，从某种特定的类到其祖先的路径称为该类的继承链(inheritance chain)。

通常， 一个祖先类可以拥有多个子孙继承链。

Java 不支持多继承。

## 5. 多态

有一个用来判断是否应该设计为继承关系的简单规则， 这就是 “is-a” 规则， 它表明子类的每个对象也是超类的对象。

“is-a” 规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以
用子类对象置换。

```java
Employee e;
e = new Employee(...); // Employee object expected
e = new Manager(...); // OK, Manager can be used as well
```

在 Java 程序设计语言中， 对象变量是多态的。

在 Java 中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。例如，下面是一个经理数组
```java
Manager[] managers = new Manager[10];
```
将它转换成 Employee[] 数组完全是合法的：
```java
EmployeeQ staff = managers; // OK
```
这样做肯定不会有问题，请思考一下其中的缘由。毕竟，如果 manager[i] 是一个Manager, 也一定是一个 Employee。 然而， 实际上， 将会发生一些令人惊讶的事情。要切记 managers和 staff 引用的是同一个数组。现在看一下这条语句：
```java
staff[0] = new Employee("Harry Hacker", . . .);
```
编译器竟然接纳了这个赋值操作。但在这里，stafflO] 与 manager[0] 引用的是同一个对象， 似乎我们把一个普通雇员擅自归入经理行列中了。 这是一种很忌伟发生的情形，当调用 managers[0].setBonus(1000) 的时候， 将会导致调用一个不存在的实例域， 进而搅乱相邻存储空间的内容。

为了确保不发生这类错误，所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。例如，使用 new managers[10] 创建的数组是一个经理数组。
如果试图存储一个 Employee类型的引用就会引发 ArrayStoreException 异常。

## 6. 理解方法调用

弄清楚如何在对象上应用方法调用非常重要。下面假设要调用 x.f(args)，隐式参数 x 声明为类 C 的一个对象。下面是调用过程的详细描述：
1. 编译器査看对象的声明类型和方法名。假设调用 x.f(param，) 且隐式参数 x 声明为 C 类的对象。需要注意的是：有可能存在多个名字为 f，但参数类型不一样的方法。例如，可能存在方法 f(int) 和方法 f(String)。编译器将会一一列举所有 C 类中名为 f 的方法和其超类中访问属性为 public 且名为 f 的方法（超类的私有方法不可访问）。

    至此， 编译器已获得所有可能被调用的候选方法。
    
1. 接下来，编译器将査看调用方法时提供的参数类型。如果在所有名为 f 的方法中存在
一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重栽解析（ overloading resolution)。

    由于允许类型转换，所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法， 或者发现经过类型转换后有多个方法与之匹配， 就会报告一个错误。

    至此，编译器已获得需要调用的方法名字和参数类型。

1. 如果是 private 方法、 static 方法、 final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定（static binding )。与此对应的是，调用的方法依赖于隐式参数的实际类型， 并且在运行时实现动态绑定。

1. 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与 x 所引用对象的实
际类型最合适的那个类的方法。假设 x 的实际类型是 D，它是 C 类的子类。如果 D 类定义了方法 f(String)，就直接调用它；否则， 将在 D 类的超类中寻找 f(String，) 以此类推。







方法的名字和参数列表称为方法的签名。如果在子类中定义了一个与超类签名相同的方
法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。  
不过，返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。