# 反射
>time: 2018-02-05 15:30:40  

反射库（ reflection library) 提供了一个非常丰富且精心设计的工具集， 以便编写能够动态操纵 Java 代码的程序。这项功能被大量地应用于 JavaBeans 中， 它是 Java 组件的体系结构。使用反射，Java 可以支持 Visual Basic 用户习惯使用的工具。特别是在设计或运行中添加新类时，能够快速地应用开发工具动态地查询新添加类的能力。

能够分析类能力的程序称为反射（reflective)。反射机制的功能极其强大，在下面可以看到， 反射机制可以用来：
* 在运行时分析类的能力
* 在运行时查看对象，例如，编写一个 toString 方法提供所有类使用。
* 实现通用的数组操作代码。
* 利用 Method 对象，这个对象很像 C++ 中的函数指针。

反射是一种功能强大且复杂的机制。使用它的主要人员是工具构造者，而不是应用程序员。

## 1. Class 类

在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。 虚拟机利用运行时类型信息选择相应的方法执行。保存这些信息的类被称为 Class, 这个名字很容易让人混淆。Class 对象将表示一个特定类的属性。 

```java
Employee e = new Employee("Test", 10000, 2018, 2, 5);
Class cl = e.getClass();
```

 

* getClass()：Object 类中的方法将会返回一个 Class类型的实例。
* getName()：方法将返回类的名字  
* forName(String className)：Class 静态方法，获得类名对应的 Class 对象。这个方法只有在 className 是类名或接口名时才能够执行。否则，forName方法将抛出一个 checked exception ( 已检查异常）。无论何时使用这个方法，都应该提供一个异常处理器（ exception handler)。  
* newlnstance()：动态地创建一个类的实例，`e.getClass().newInstance()`。 newInstance 方法第阿勇默认的构造器初始化新创建的对象。如果这个类没有默认的构造器，就会抛出一个异常。如果需要以这种方式向希望按名称创建的类的构造器提供参数，就不要使用上面的那条语句，而必须使用 Constructor 类中的 newInstance 方法。

```java
package core;

public class Test {

    public static void main(String[] args) {
        try {
            Constructor con = Class.forName("core.A").
                    getConstructor(String.class);
            A a = (A)con.newInstance("This is A class");
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
class A {
    public A(String name) {
        System.out.println(name);
    }
}
```

```java
try {
    String className = "java.util.Random";
    Class cl = Class.forName(className);
} catch (ClassNotFoundException e) {
    e.printStackTrace();
}
```

将 forName 与 newInstance 配合起来使用，可以根据存储在字符串中的类名创建一个对象。
```java
try {
    String s = "java.util.Random";
    Random m = (Random)Class.forName(s).newInstance();
} catch (InstantiationException | 
        IllegalAccessException | 
        ClassNotFoundException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}
```


提示：在启动时，包含 main 方法的类被加载。它会加载所有需要的类。这些被加栽的类又要加载它们需要的类，以此类推。对于一个大型的应用程序来说，这将会消耗很多时间，用户会因此感到不耐烦。可以使用下面这个技巧给用户一种启动速度比较快的幻觉。不过，要确保包含 main 方法的类没有显式地引用其他的类。首先，显示一个启动画面；然后，通过调用 Class.forName 手工地加载其他的类。

### 获得 Class 类对象的三种方法
1. `cl.getClass()`
2. `Class.forName(String className);`
3. `Class cl1 = Random.class; Class cl2 = int.class; Class cl3 = Double[].class;`

请注意， 一个 Class 对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但 int.class 是一个 Class 类型的对象。

**注释**： Class类实际上是一个泛型类。例如，Employee.class 的类型是 Class<Employee>。没有说明这个问题的原因是：它将已经抽象的概念更加复杂化了。在大多数实际问题中，可以忽略类型参数，而使用原始的 Class 类。

虚拟机为每个类型管理一个 Class对象。因此，可以利用 == 运算符实现两个类对象比较的操作。 例如
```java
if (e.getClass() == Employee.class) ...
```

## 2. 捕获异常

当程序运行过程中发生错误时，就“会抛异常”。抛出异常比终止程序要灵活得多，这是因为可以提供一个当程序运行过程中发生错误时“捕获”异常的处理器，就会“抛出异常(handler)对异常情况进行处理。

如果没有提供处理器，程序就会终止，并在控制台上打印出一条信息，其中给出了异常的类型。

异常有两种类型：
* 未检查异常
* 已检查异常

* 已检查异常，编译器将会检查是否提供了处理器。
* 未检查异常，编译器不会査看是否为这些错误提供了处理器。毕竟，应该精心地编写代码来避免这些错误的发生， 而不要将精力花在编写异常处理器上。例如，访问 null 引用。

并不是所有的错误都是可以避免的。如果竭尽全力还是发生了异常，编译器就要求提供一个处理器。Class.forName 方法就是一个抛出已检查异常的例子。
```java
try {
    statements that might throw exceptions
}catch (Exception e) {
    handler action
}
```

对于已检查异常，只需要提供一个异常处理器。可以很容易地发现会抛出已检査异常的方法。如果调用了一个抛出已检查异常的方法，而又没有提供处理器，编译器就会给出错误报告。

### java.lang.Class .10
* static Class forName(String className)  
    返回描述类名为 className 的 Class 对象。
* Object newInstance()  
    返回这个类的一个新实例

### java.lang.reflect.Constructor 1.1
* Object newInstance(Ojbect[] args)  
    构造一个这个构造器所属类的新实例。  
    参数: args  这是提供给构造器的参数。

### java.lang.Throwable 1.0
* voie printStackTrance()  
    将 Throwable 对象和栈的轨迹输出到标准错误流。


## 3. 利用反射分析类的能力

Class类中的 getFields、getMethods 和 getConstructors 方法将分别返回类提供的 public 域、方法和构造器数组，其中包括超类的公有成员。Class 类的 getDeclaredFields、getDeclaredMethods 和 getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。

### java.lang.Class 1.0
* Field[] getFields() 1.1
* Field[] getDeclaredFields() 1.1
    getFields 方法将返回一个包含 Fields 对象的数组，这些对象记录了这个类或其超类的公有域。getDeclaredField方法也将返回包含 Field 对象的数组，这些对象记录了这个类的全部域。如果类中没有域，或者  Class 对象描述的是基本类型或数组类型，这些方法将返回一个长度为 0 的数组。
* Method[] getMethods() 1.1
* Method[] getDeclaredMethods() 1.1
    返回包含 Method 对象的数组：getMethods将返回所有的公有方法， 包括从超类继承来的公有方法；getDeclaredMethods返回这个类或接口的全部方法， 但不包括由超类继承了的方法。
* Constructor[] getConstructors() 1.1
* Constructor[] getDeclaredConstructors() 1.1
    返回包含 Constructor 对象的数组，其中包含了 Class 对象所描述的类的所有公有构造器（getConstructors) 或所有构造器（getDeclaredConstructors)。

### java.lang.reflect.Field 1.1
### java.lang.reflect.Method 1.1
### java.lang.reflect.Constructor 1.1
* Class getDeclaringClass()
    返回一个用于描述类中定义的构造器、方法或域的 Class 对象。
* Class[] getExceptionTypes() (在 Constructor 和 Method 类中）
    返回一个用于描述方法抛出的异常类型的 Class 对象数组。
* int getModifiers()
    返回一个用于描述构造器、方法或域的修饰符的整型数值。使用 Modifier 类中的这个方法可以分析这个返回值。
* String getName()
    返冋一个用于描述构造器、 方法或域名的字符串。
* Class[] getParameterTypes() (在 Constructor 和 Method 类 中）
    返回一个用于描述参数类型的 Class 对象数组。
* Class getReturnType() (在 Method 类 中）
    返回一个用于描述返H类型的 Class 对象。

### java.lang.reflect.Modifier 1.1
* static String toString(int modifiers)
    返回对应 modifiers 中位设置的修饰符的字符串表7K。
* static boolean isAbstract(int modifiers)
* static boolean isFinal(int modifiers)
* static boolean isInterface(int modifiers)
* static boolean isNative(int modifiers)
* static boolean isPrivate(int modifiers)
* static boolean isProtected(int modifiers)
* static boolean isPublic(int modifiers)
* static boolean isStatic(int modifiers)
* static boolean isStrict(int modifiers)
* static boolean isSynchronized(int modifiers)
* static boolean isVolatile(int modifiers)
    这些方法将检测方法名中对应的修饰符在 modffiers 值中的位。

```java
package core;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

public class Test {

    public static void main(String[] args) {
        String name = "java.lang.Double";
        try {
            Class cl = Class.forName(name);
            Class supercl = cl.getSuperclass();
            String modifiers = Modifier.toString(cl.getModifiers());
            if (modifiers.length() > 0) {
                System.out.print(modifiers + " ");
            }
            System.out.print("class " + name);
            if(supercl != null && supercl != Object.class) {
                System.out.print(" extends " + supercl.getName());
            }
            System.out.print(" {\n");
            printConstructors(cl);
            System.out.println();
            printMethods(cl);
            System.out.println();
            printFields(cl);
            System.out.print("}");
        } catch (ClassNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        System.exit(0);
    }
    public static void printConstructors(Class cl) {
        Constructor[] constructors = cl.getConstructors();
        for(Constructor constructor : constructors) {
            String name = constructor.getName();
            System.out.print("    ");
            String modifiers = Modifier.toString(constructor.getModifiers());
            if(modifiers.length() > 0) {
                System.out.print(modifiers + " ");
            }
            System.out.print(name + "(");
            
            Class[] paramTypes = constructor.getParameterTypes();
            for (int j = 0; j < paramTypes.length; j++) {
                if (j > 0) {
                    System.out.print(", ");
                }
                System.out.print(paramTypes[j].getName());
            }
            System.out.println(");");
        }
    }
    public static void printMethods(Class cl) {
        Method[] methods = cl.getDeclaredMethods();
        for(Method method : methods) {
            Class retType = method.getReturnType();
            String name = method.getName();
            
            System.out.print("    ");
            
            String modifiers = Modifier.toString(method.getModifiers());
            if(modifiers.length() > 0) {
                System.out.print(modifiers + " ");
            }
            System.out.print(retType.getName() + " " + name + "(");
            Class[] paramTypes = method.getParameterTypes();
            for (int j = 0; j < paramTypes.length; j++) {
                if (j > 0) {
                    System.out.print(", ");
                }
                System.out.print(paramTypes[j].getName());
            }
            System.out.println(");");
        }
    }
    public static void printFields(Class cl) {
        Field[] fields = cl.getDeclaredFields();
        
        for(Field field : fields) {
            Class type = field.getType();
            String name = field.getName();
            System.out.print("    ");
            String modifiers = Modifier.toString(field.getModifiers());
            if(modifiers.length() > 0) {
                System.out.print(modifiers + " ");
            }
            System.out.println(type.getName() + " " + name + ";");
        }
    }
}
```
输出：
```
public final class java.lang.Double extends java.lang.Number {
    public java.lang.Double(double);
    public java.lang.Double(java.lang.String);

    public boolean equals(java.lang.Object);
    public static java.lang.String toString(double);
    public java.lang.String toString();
    public int hashCode();
    public static int hashCode(double);
    public static double min(double, double);
    public static double max(double, double);
    public static native long doubleToRawLongBits(double);
    public static long doubleToLongBits(double);
    public static native double longBitsToDouble(long);
    public volatile int compareTo(java.lang.Object);
    public int compareTo(java.lang.Double);
    public byte byteValue();
    public short shortValue();
    public int intValue();
    public long longValue();
    public float floatValue();
    public double doubleValue();
    public static java.lang.Double valueOf(java.lang.String);
    public static java.lang.Double valueOf(double);
    public static java.lang.String toHexString(double);
    public static int compare(double, double);
    public static boolean isNaN(double);
    public boolean isNaN();
    public static boolean isInfinite(double);
    public boolean isInfinite();
    public static boolean isFinite(double);
    public static double sum(double, double);
    public static double parseDouble(java.lang.String);

    public static final double POSITIVE_INFINITY;
    public static final double NEGATIVE_INFINITY;
    public static final double NaN;
    public static final double MAX_VALUE;
    public static final double MIN_NORMAL;
    public static final double MIN_VALUE;
    public static final int MAX_EXPONENT;
    public static final int MIN_EXPONENT;
    public static final int SIZE;
    public static final int BYTES;
    public static final java.lang.Class TYPE;
    private final double value;
    private static final long serialVersionUID;
}
```

## 4. 在运行时使用反射分析对象

