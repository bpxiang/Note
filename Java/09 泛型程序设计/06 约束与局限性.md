# 约束与局限性
>time: 2018-05-21 15:06:07

使用 Java 泛型时需要考虑的一些限制。大多数限制都是由类型擦除引起的。

## 1. 不能用基本类型实例化类型参数
不能用类型参数代替基本类型。原因是类型擦除。 没有 `Pair<double>`，只有 `Pair<Double>`。擦除之后，Pair 类含有 Object 类型的域，而 Object 不能存储 double 值。

这样做与 Java 语言中基本类型的独立状态相一致。这并不是一个致命的缺陷——只有 8 种基本类型，当包装器类型（wrapper type) 不能接受替换时，可以使用独立的类和方法处理它们。

## 2. 运行时类型查询只适用于原始类型
虚拟机中的对象总有一个特定的非泛型类型。因此，所有的类型查询只产生原始类型。  
`if (a instanceof Pair<String>) // Error`  
实际上仅仅测试 a是否是任意类型的一个 Pair。下面的测试同样如此：  
`if (a instanceof Pair<T>) // Error`  
或强制类型转换：  
`Parir<String> p = (Pair<String>) ; // Waring--can only test that a is a Pair`

为提醒这一风险，试图查询一个对象是否属于某个泛型类型时，倘若使用 instanceof 会得到一个编译器错误，如果使用强制类型转换会得到一个警告。  
同样的道理， getClass 方法总是返回原始类型。
```java
Pair<String> stringPair = ...;
Pair<Employee> employeePair = ...;
if (stringPair.getClass == employeePair.getClass()) // they are equal
```
其比较的结果是 true，这是因为两次调用 getClass 都将返回 Pair.class。

## 3. 不能创建参数化类型的数组
不能实例化参数化类型的数组  
`Pair<String><> table = new Pair<String>[10]; // Error`  
这有什么问题呢？ 擦除之后，table的类型是 Pair[]。可以把它转换为 Object[]:  
`Object[] objarray = table;`  
数组会记住它的元素类型，如果试图存储其他类型的元素，就会抛出一个 `ArrayStoreException` 异常：  
`objarray[0] = "Hello"; // Error--component type is Pair`  
不过对于泛型类型，擦除会使这种机制无效。以下赋值：  
`objarray[0] = new Pair<Employee>();`  
能够通过数组存储检査， 不过仍会导致一个类型错误。 出于这个原因， 不允许创建参数化类型的数组。

需要说明的是，只是不允创建这些数组，而声明类型为 `Pair<String>[]` 的变量仍是合法的。不过不能用 `new Pair<String>[10]` 初始化这个变量。

***
**注释**： 可以声明通配类型的数组，然后进行类型转换：  
`Pair<String>[] table = (Pair<String>[]) new Pair<?>[10];`  
结果将是不安全的。如果在 table[0] 中存储了一个 `Pair<String>`，然后对 `table[0].getFirst()` 调用一个 String 方法，会得到一个 `ClassCastException` 异常。
***
**提示**： 如果需要收集参数化类型对象，只有一种安全而有效的方法：使用`ArrayList:ArrayList<Pair<String>>`。
***

## 4. Varargs 警告
