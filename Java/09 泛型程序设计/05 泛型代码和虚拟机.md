# 泛型代码和虚拟机
>time: 2018-5-14 14:56:45

虚拟机没有泛型类型对象—所有对象都属于普通类。在泛型实现的早期版本中，甚至能够将使用泛型的程序编译为在 1.0 虚拟机上运行的类文件！这个向后兼容性在 Java 泛型开发的后期被放弃了。

## 1. 类型擦除

无论何时定义一个泛型类型，都自动提供了一个相应的原始类型(raw type)。原始类型的名字就是删去类型参数后的泛型类型名。擦除（erased）类型变量，并替换为限定类型 （无限定的变量用 Object）。

```java
public class Pair<T> {
    private T first;
    private T second;
    
    public Pair(T first, T second) { 
        this.first = first; 
        this.second = second; 
    }

    public T getFirst() { return first; }
    public T getSecond() { return second; }

    public void setFirst(T newValue) { first = newValue; }
    public void setSecond(T newValue) { second = newValue; }
}
```
#### 原始类型：
```java
public class Pair {
    private Object first;
    private Object second;

    public Pair(Object first, Object second) {
        this.first = first;
        this.second = second;
    }

    public Object getFirst(){ return first; }
    public Object getSecond() {return second; }

    public void setFirst(Object newValue) { first = newValue; }
    public void setSecond(Object newValue) { second = newValue; }
}
```
因为 T 是一个无限定的变量，所以直接用 Object 替换。

原始类型用第一个限定的类型变量来替换，如果没有给定限定就用 Object 替换。

```java
public class Interval<T extends Comparable & Serializable> implements Serializable {
    private T lower;
    private T upper;
    ...
    public Interval(T first, T second) {
        if(first.compareTo(second) <= 0) {
            lower = first;
            upper = second;
        }else {
            lower = second;
            upper = first;
        }
    }
}
```
#### 原始类型 Interval 如下所示：
```java
public class Interval implements Serializable {
    private Comparable lower;
    private Comparable upper;
    ...
    public Interval(Comparable first, Comparable second) {
        ...
    }
}
```
***
**注释**: `class Interval<T extends Comparable & Serializable>`，这样做，原始类型用 Serializable 替换 T，而编译器在必要时要向 Comparable 插入强制类型转换。为了提高效率，应该将标签（tagging）接口（即没有方法的接口）放在边界列表的末尾。
***

## 2. 翻译泛型表达式
