# 数据类型
在 Java 中，一共有 8 种基本类型（primitive type），其中有 4 种整型、2 种浮点型、1 种用于表示 Unicode 编码的字符单元的字符类型 char 和 1 种用于表示真值的 boolean 类型。

***注释：*** Java 有一个能够表示任意精度的算数包，通常称为“大数值”（big number）。虽然被称为大数值，但并不是一种 Java 类型，而是一个 Java 对象。

## 整型
整型用于表示没有小数部分的数值，它允许是负数。Java 提供了 4 种整型。  

|类型|存储需求|取值范围|
|:---:|:---:|:---|
|  byte  |  1 字节  |  -128 ~ 127  |
|  short  |  2 字节  |  -32 768 ~ 32 767  |
|  int  |  4 字节  |  -2 147 483 648 ~ 2 147 483 647 ( 正好超过 20 亿 )  |
|  long  |  8 字节  |  -9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807  |

在通常情况下，int 类型最常用。

在 Java 中，整数的范围与运行 Java 代码的机器无关。这就解决了软件从一个平台移植到另一个平台，或者在同一个平台中的不同操作系统之间进行移植给程序员带来的诸多问题。由于 Java 程序必须保证在所有机器上都能够得到相同的运行结果，所以各种数据类型的取值范围必须固定。  

长整型数值有一个后缀 L 或 l（如 4000000000L）。十六进制数值有一个前缀 0x 或 0X（0xCAFE）。八进制有一个前缀 0（010 对应八进制中的 8），八进制表示法比较容易混淆，所有建议最好不要使用八进制常数。

从 Java 7 开始，加上前缀 0b 或 0B 就可以表示二进制（0b1001 就是9）。

从 Java 7 开始，还可以为数字字面量加下划线，如用1_000_000(或用 0b1111_0100_0010_0100_0000) 表示一百万。这些下划线只是为了让人更易读。Java 编译器会去除这些下划线。

在 Java 中，所有的数值类型所占据的字节数量与平台无关。

***注意：*** Java 没有任何无符号（unsigned）形式的 int、long、short 或 byte 类型。

## 浮点类型
浮点类型用于表示有小数部分的数值。在 Java 中有两种浮点类型。

|  类型  |  存储需求  |  取值范围  |
|:---:|:---:|:---:|
| float  |  4 字节  |  大约 ± 3.402 823 47E+38F (有效位数为 6 ~ 7 位)  |
|  double  |  8 字节  |  大约 ± 1.797 693 134 862 315 70E+308 (有效位数为 15 位)  |

double 表示这种类型的数值精度是 float 类型的两倍（有人称之为双精度数值）。绝大部分应用程序都采用 double 类型。在很多情况下，float 类型的精度很难满足需求。实际上，只有很少的情况适合使用 float 类型。

float 类型的数值有一个后缀 F 或 f（例如，3.14F）。没有后缀 F 的浮点数值（如 3.14）默认为 double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d （例如， 3.14D）。

***注释：*** 可以使用十六进制表示浮点数值。例如，0.125=2^-3^ 可以表示成 0xl.0p-3。在十六进制表示法中，使用 p 表示指数，而不是 e。 注意，尾数采用十六进制，指数采用十进制。指数的基数是 2，而不是 10。

所有的浮点数值都遵循 IEEE 754 规范，具体来说，下面是用于表示溢出和出错情况的三个特殊的浮点数值：
* 正无穷大 - `Double.POSITIVE_INFINITY`
* 负无穷大 - `Double.NEGATIVEJNFINITY`
* NaN（不是一个数字）- `Double.NaN`

例如，一个整数除以 0 的结果为正无穷大。计算 0/0 或者负数的平方根结果为 NaN。

***注释：*** 常量 `Double.POSITIVE_INFINITY`、`Double.NEGATIVEJNFINITY`和`Double.NaN` ( 以及相应的 Float 类型的常量)分别表示这三个特殊的值，但在实际应用中很少遇到。

所有“ 非数值” 的值都认为是不相同的。 然而， 可以使用 Double.isNaN 方法:

```
if (Double.isNaN(x)) // check whether x is "not a number"
```

***警告：*** 浮点数值不适用于无法接受舍入误差的金融计算中。这种舍入误差的主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数 1/10。这就好像十进制无法精确地表示分数 1/3 —样。如果在数值计算中不允许有任何舍入误差，就应该使用 BigDecimal 类。

## char 类型
char 类型原本用于表示单个字符。不过，现在情况已经所有变化。如今，有些 Unicode 字符可以用一个 char 描述值，另外一些 Unicode 字符则需要两个 chart 值。

char 类型的字面量值要用单引号括起来。char 类型的值可以表示为十六进制值，其范围从 \u0000 到 \Uffff 例如 \u2122 表示注册符号 (™), \u03C0 表示希腊字母 π。

|  转移序列  |  名称  |  Unicode  |
|:---:|:---:|:---:|
|  \b  |  退格  |  \u0008  |
|  \t  |  制表  |  \u0009  |
|  \n  |  换行  |  \u000a  |
|  \r  |  回车  |  \u000d  |
|  \\"  |  双引号  |  \u0022  |
|  \\'  |  单引号  |  \u0027  |
|  \\\\  |  反斜杠  |  \u005c  |

***警告：*** Unicode 转义序列会在解析代码之前得到处理。例如， "\u0022+\u0022" 并不是一个由引号(U+0022) 包围加号构成的字符串。 实际上，\u0022 会在解析之前转换为 "，这会得到也就是一个空串。  

更隐秘地， 一定要当心注释中的 \u。 注释  
`// \u00A0 is a newline`  

会产生一个语法错误，因为读程序时 \u00A0 会替换为一个换行符。类似地，下面这个注释:  
`// Look inside c:\users`

也会产生一个语法错误， 因为 \u 后面并未跟着 4 个十六进制数。

## Unicode 和 char 类型
***码点 ( code point )*** 是指与一个编码表中的某个字符对应的代码值。在 Unicode 标准中， 码点采用十六进制书写，并加上前缀U+, 例如U+0041就是拉丁字母A的码点。Unicode的 码点可以分成 17 个代码级别(codeplane)。第一个代码级别称为基本的多语言级别(basic multilingual plane ), 码点从 U+0000 到 U+FFFF，其中包括经典的 Unicode 代码；其余的 16 个级别码点从 U+10000 到 U+10FFFF，其中包括一些辅助字符(supplementary character)。

UTF-16 编码采用不同长度的编码表示所有 Unicode 码点。在基本的多语言级别中， 每个 字符用16位表示，通常被称为代码单元(codeunit); 而辅助字符采用一对连续的代码单元 进行编码。 这样构成的编码值落人基本的多语言级别中空闲的 2048 字节内， 通常被称为替 代区域(surrogate area) [ U+D800 ~ U+DBFF 用于第一个代码单兀，U+DC00 ~ U+DFFF 用 于第二个代码单元 ]。 这样设计十分巧妙， 我们可以从中迅速地知道一个代码单元是一个字 符的编码， 还是一个辅助字符的第一或第二部分。

在 Java 中，char 类型描述了 UTF-16 编码中的一个代码单元。

强烈建议不要在程序中使用 char 类型，除非确实需要处理 UTF-16 代码单元。最好将字符串作为抽象数据类型处理。

## boolean 类型
boolean（boolean）类型有两个值：false 和 true，用来判定逻辑条件。整形值和布尔值之间不能进行相互转换。
