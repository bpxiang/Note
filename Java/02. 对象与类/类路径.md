# 类路径
>time: 2017-12-11 15:56:46

类文件也可以存储在 JAR（Java归档）文件中。在一个 JAR 文件中，可以包含多个压缩形式的类文件和子目录，这样既可以节省又可以改善性能。

提示: JAR 文件使用 ZIP 格式组织文件和子目录。可以使用所有 ZIP 实用程序查看内部的 tr.jar 以及其他的 JAR 文件。

为了使类能够被多个程序共享，需要做到下面几点：
1. 把类放在一个目录中。
1. 将 JAR 文件放在一个目录中。
1. 设置类路径（class path）。类路径是所有包含类文件的路径的集合。

从 Java SE 6 开始，可以在 JAR 文件目录中指定通配符，  
`/home/user/classdir:.:/home/user/archives/'*'`  
或者  
`c:\calssdir;.c:\archives\*`  
但在 UNIX 中，禁止使用 * 以防止 shell 命令进一步扩展。

由于运行时库文件（rt.jar 和在 jre/lib 与 jre/lib/ext 目录下的一些其他的 JAR 文件）会被自动地搜索，所以不必将它们显式地列在类路径中。

警告：javac 编译器总是在当前的目录中查找文件，但 Java 虚拟机仅在类路径中有 “.” 目录的时候才查找当前目录。如果没有设置类路径，那也不会产生任何问题，默认的类路径包含 “.” 目录。然而，如果设置了类路径却忘记了包含 “.” 目录，则程序任然可以通过编译，但不能运行。

编译器定位一个文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包，并查询所有的 import 指令，确定其中是否包含了被引用的类。

编译器的任务不止这些，它还要查看源文件（Source files）是否比类文件新。如果是这样的话，那么源文件就会被自动地重新编译。在前面已经知道，仅可以导入其他包中的公有类。一个源文件只能包含一个公有类，并且文件名必须与公有类匹配。因此，编译器很容易定位公有类所在的源文件。当然，也可以从当前包中导入非公有类。这些类可能定义在与类名不同的源文件中。如果从当前包中导入一个类，编译器就要自动搜索当前包中的所有源文件，一遍确定哪个源文件定义了这个类。

# 1. 设置类路径

最好采用 -classpath （或 -cp）选项指定类路径：  
`java -classpath /home/user/classdir:.:/home/user/archives/archive.jar MyProg`  
或者  
`java -calsspath c:\classdir;.;a:\archives\archive.jar MyProg`  

整个指令应该书写在一行中。将这样一个长的命令行放在一个 shell 脚本或一个批处理文件中是一个不错的注意。

利用 -classpath 选项设置类路径是首选方法，也可以通通过设置 CLASSPATH 环境变量完成这个操作。  
bash（Bourne Again Shell）中：  
`export CLASSPATH=/home/user/classdir:.:/home/user/archives/archive.jar`  
Windows shell 中：  
`set CLASSPATH=/home/user/classdir:.:/home/user/archives/archive.jar`  
直到退出 shell 为止，类路径设置均有效。

警告： 有人建议将 CLASSPATH 环境变量设置为永久不变的值。 总的来说这是一个很糟
糕的主意。人们有可能会忘记全局设置， 因此， 当使用的类没有正确地加载进来时， 会感到很奇怪。 一个应该受到it责的示例是 Windows中 Apple的 QuickTime安装程序。 它进行了全局设置， CLASSPATH 指向一个所需要的 JAR 文件， 但并没有在类路径上包含当前路径。 因此， 当程序编译后却不能运行时， 众多的 Java程序员花费了很多精力去解决这个问题。

警告： 有人建议绕开类路径， 将所有的文件放在 jre/lib/ext 路径。这是一个极坏的主意，其原因主要有两个： 当手工地加载其他的类文件时， 如果将它们存放在扩展路径上， 则不能正常地工作。此外， 程序员经常会忘记 3 个月前所存放文件的位置。 当类加载器忽略了曾经仔细设计的类路径时， 程序员会毫无头绪地在头文件中查找。 事实上， 加栽的是扩展路径上已长时间遗忘的类。