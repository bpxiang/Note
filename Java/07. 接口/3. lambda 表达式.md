# lambda 表达式
>time: 2018-02-26 15:40:11  

## 1. 为什么引入 lambda 表达式

lambda 表达式是一个可传递的代码块，可以在以后执行一次火多次。
```java
class LengthComparator implements Comparator<String> {
    public int compare(String first, String second) {
        return first.length() - second.length();
    }
}
...
Arrays.sort(strings, new LengthComparator());
```
compare 方法不是立即调用。实际上，在数组完成排序之前，sort 方法会一直调用 compare 方法，只要元素的顺序不正确就会重新排列元素。将比较元素所需的代码段放在 sort 方法中，这个代码将与其余的排列逻辑继承。

Java 设计者很长时间以来一直拒绝增加这个特性。毕竟，Java 的强大之处就在于其简单性和一致性。如果只要一个特性能够让代码稍简洁一些，就把这个特性增加到语言中，这个语言很快就会变得一团糟，无法管理。不过，在另外那些语言中，并不只是创建线程或注册按钮点击事件处理器更容易；它们的大部分 API 都更简单、更一致而且更强大。在 Java 中，也可以编写类似的 API 利用类对象实现特定的功能，不过这种 API 使用可能很不方便。

## 2. lambda 表达式的语法
lambda 表达式就是一个代码块，以及必须传人代码的变量规范。

Java中的一种 lambda表达式形式：参数， 箭头（->) 以及一个表达式。如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在 {} 中并包含显式的 return语句。
```java
(String first, String second)
    -> first.length() - second.length()
```
```java
(String first, String secode) -> 
    {
        if (first.length() < secod.length()) return -1;
        else if (first.length() > second.length()) return 1;
        else return 0;
    }
```
即使 lambda 表达式没有参数，仍然要提供空括号，就像无参数方法一样：  
`() -> { for (inti = 100;i >= 0;i ) System.out.println(i); }`  
如果可以推导出一个 lambda表达式的参数类型，则可以忽略其类型。
```java
Comparator<String> comp
    =  (first, second) // Same as (String first, String second)
        -> first.length() - second.length();
```
在这里， 编译器可以推导出 first 和 second必然是字符串， 因为这个 lambda表达式将赋给一个字符串比较器。

如果方法只有一 参数， 而且这个参数的类型可以推导得出，那么甚至还可以省略小括号：
```java
ActionListener listener = event ->
    System.out.println("The time is " + new Date());
    // Instead of (event) -> ... or (ActionEvent event) -> ...
```
无需指定 lambda 表达式的返回类型。lambda 表达式的返回类型总是会由上下文推导得出。  
`(String first, String second) -> first.length() - second.length()`  
可以在需要 im类型结果的上下文中使用。

**注释**： 如果一个 lambda 表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。 例如，`(int x)-> { if (x >= 0) return 1;}` 就不合法。

```java
import java.util.Arrays;
import java.util.Date;

import javax.swing.JOptionPane;
import javax.swing.Timer;

public class LambdaTest {
    public static void main(String[] args) {
        String[] planets = new String[] {"Mercury", "Venus", "Earth", "Mars",
                "Jupiter", "Saturn", "Uranus", "Neptune"};
        System.out.println(Arrays.toString(planets));
        System.out.println("Sorted in dictionary order:");
        Arrays.sort(planets);
        System.out.println(Arrays.toString(planets));
        System.out.println("Sorted by length:");
        Arrays.sort(planets, (first, second) -> first.length() - second.length());
        System.out.println(Arrays.toString(planets));
        
        Timer t = new Timer(1000, event -> 
                System.out.println("The thie is " + new Date()));
        t.start();
        
        // keep program running until user selects "OK"
        JOptionPane.showMessageDialog(null, "Quit program?");
        System.exit(0);
    }
}
```
#### 输出：
```bash
[Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune]
Sorted in dictionary order:
[Earth, Jupiter, Mars, Mercury, Neptune, Saturn, Uranus, Venus]
Sorted by length:
[Mars, Earth, Venus, Saturn, Uranus, Jupiter, Mercury, Neptune]
The thie is Mon Feb 26 16:23:02 CST 2018
The thie is Mon Feb 26 16:23:03 CST 2018
The thie is Mon Feb 26 16:23:04 CST 2018
The thie is Mon Feb 26 16:23:05 CST 2018
```

## 3. 函数式接口
Java 中已经有很多封装代码块的接口，如 ActionListener 或 Comparator。lambda 表达式与这些接口是兼容的。

对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个 lambda 表达式。这种接口称为**函数式接口 （functional interface)**。

**注释**：你可能想知道为什么函数式接口必须有一个抽象方法。不是接口中的所有方法都是抽象的吗？实际上，接口完全有可能重新声明 Object 类的方法， 如 toString 或 clone，这些声明有可能会让方法不再是抽象的。(Java API 中的一些接口会重新声明 Object 方法来附加 javadoc 注释 Comparator API 就是这样一个例子。) 更重要的是，在 JavaSE 8 中， 接口可以声明非抽象方法。

为了展示如何转换为函数式接口，下面考虑 Arrays.sort 方法。它的第二个参数需要一个 Comparator 实例，Comparator 就是只有一个方法的接口，所以可以提供一个 lambda 表达式：
```java
Arrays.sort(words, 
    (first, second) -> first.length() - second.length());
```

在底层，Arrays.sort 方法会接收实现了 Comparator<String> 的某个类的对象。 在这个对象上调用 compare 方法会执行这个 lambda 表达式的体。这些对象和类的管理完全取决于具体实现，与使用传统的内联类相比，这样可能要高效得多。最好把 lambda 表达式看作是一个函数，而不是一个对象，另外要接受 lambda 表达式可以传递到函数式接口。

lambda 表达式可以转换为接口，这一点让 lambda 表达式很有吸引力。具体的语法很简短。
```java
Timer t = new Timer(1000, event ->
    {
        System.out.println("At the tone, the time is " + new Date();
        Toolkit.getDefaultToolkit().beep();
    });
```
与使用实现了 ActionListener 接口的类相比， 这个代码可读性要好得多。

实际上，在 Java中，对 lambda 表达式所能做的也只是能转换为函数式接口。在其他支持函数字面量的程序设计语言中，可以声明函数类型（如（String, String)-> int)、声明这些类型的变量，还可以使用变量保存函数表达式。不过，Java设计者还是决定保持我们熟悉的接口概念， 没有为 Java语言增加函数类型。

**注释**：甚至不能把 lambda 表达式赋给类型为 Object 的变量，Object 不是一个函数式接口。

Java API 在 java.util.fimction 包中定义了很多非常通用的函数式接口。其中一个接口 BiFunction<T, U, R> 描述了参数类型为 T 和 U 而且返回类型为 R 的函数。可以把我们的字符串比较 lambda 表达式保存在这个类型的变量中：
```java
BiFunction<String, String, Integer> comp
    = (first, second) -> first.length() - second.length();
```
不过，这对于排序并没有帮助。没有哪个 Arrays.sort 方法想要接收一个 BiFunction。如果你之前用过某种函数式程序设计语言，可能会发现这很奇怪。不过，对于 Java 程序员而言，这非常自然。类似 Comparator 的接口往往有一个特定的用途，而不只是提供一个有指定参数和返回类型的方法。Java SE 8 沿袭了这种思路。想要用 lambda 表达式做某些处理，还是要谨记表达式的用途，为它建立一个特定的函数式接口。

`java.util.function` 包中有一个尤其有用的接口 Predicate:
```java
public interface Predicate<T>
{
    boolean test(T t);
    // Additional default and static methods
}
```

ArrayList 类有一个 removelf 方法， 它的参数就是一个 Predicate。这个接口专门用来传递 lambda 表达式。例如，下面的语句将从一个数组列表删除所有 null 值：  
`list.removeIf(e -> e == null);`

## 4. 方法引用
有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。例如，假设你希望只要出现一个定时器事件就打印这个事件对象。 当然， 为此也可以调用：  
`Timer t = new Timer(1000, event -> System.out.println(event));`  
但是，如果直接把 println 方法传递到 Timer 构造器就更好了。具体做法如下：  
`Timer t = new Timer(1000, System.out::println);`  
表达式 `System.out::println` 是一个方法引用（ method reference )，它等价于 lambda 表达式 `x -> System.out.println(x)`。

假设你想对字符串排序， 而不考虑字母的大小写。可以传递以下方法表达式：  
`Arrays.sort(strings, String::compare)`  
从这些例子可以看出， 要用 :: 操作符分隔方法名与对象或类名。主要有 3 种情况：
* `object::instanceMethod`
* `Class::staticMethod`
* `Class::instanceMethod`

在前 2 种情况中， 方法引用等价于提供方法参数的 lambda 表达式。前面已经提到，`System.out::println` 等价于 `x -> System.out.println(x)`。 类似地， `Math::pow` 等价于 `(x，y)->Math.pow(x, y)`。

对于第 3 种情况，第 1 个参数会成为方法的目标。例如，`String::compareToIgnoreCase` 等同于 `(x, y)-> x.compareToIgnoreCase(y)`。

**注释**： 如果有多个同名的重栽方法， 编译器就会尝试从上下文中找出你指的那一个方法。例如，Math.max 方法有两个版本，一个用于整数，另一个用于 double值。选择哪一个版本取决于 Math::max 转换为哪个函数式接口的方法参数。类似于 lambda 表达式， 方法引用不能独立存在，总是会转换为函数式接口的实例。

可以在方法引用中使用 this 参数。例如，`this::equals` 等同于 `x-> this.equals(x)`。 使用 super 也是合法的。下面的方法表达式  
`super::instanceMethod`  
使用 this 作为目标，会调用给定方法的超类版本。

```java
class Greeter {
    public void greet() {
        System.out.println("Hello, World");
    }
}

class TimedGreeter extends Greeter {
    public void greet() {
        Timer t = new Timer(1000, super::greet);
        t.start();
    }
}
```

`TimedGreeter.greet` 方法开始执行时， 会构造一个 Timer, 它会在每次定时器滴答时执行 `super::greet` 方法。这个方法会调用超类的 greet 方法。

## 5. 构造器引用
构造器引用与方法引用很类似，只不过方法名为 new。例如，Person::new 是 Person 构造器的一个引用。哪一个构造器呢？这取决于上下文。假设你有一个字符串列表。可以把它转换为一个 Person 对象数组，为此要在各个字符串上调用构造器，调用如下：
```java
ArrayList<String> names = ...;
Stream<Person> stream = names.stream().map(Person::new);
List<Person> people = stream.collect(Collectors.toList());
```
如果有多个 Person 构造器，编译器会选择有一个 String 参数的构造器，因为它从上下文推导出这是在对一个字符串调用构造器。

可以用数组类型建立构造器引用。例如，int[]::new 是一个构造器引用，它有一个参数：即数组的长度。这等价于 lambda 表达式 x -> new int[x]。

Java有一个限制，无法构造泛型类型 T 的数组。数组构造器引用对于克服这个限制很有用。表达式 new T[n] 会产生错误，因为这会改为 new Object[n]。对于开发类库的人来说，这是一个问题。例如，假设我们需要一个 Person 对象数组。 Stream 接口有一个 toArray 方法可以返回 Object 数组：`Object[] people = stream.toArray();`

用户希望得到一个 Person引用数组，而不是 Object 引用数组。流库利用构造器引用解决了这个问题。可以把 Person[]::new 传入 toArray 方法：  
`Person[] people = stream.toArray(Person[]::new);`  
toArray 方法调用这个构造器来得到一个正确类型的数组。然后填充这个数组并返回。

## 6. 变量作用域
```java
public static void repeatMessage(String text, int delay) {
    ActionListener listener = event -> {
        System.out.println(text);
        Toolkit.getDefaultToolkit().beep();
    };
    new Time(delay, listener).start();
}
```
调用：
```java
repeatMessage("Hello", 1000); // Prints Hello every 1,000 milliseconds
```

现在来看 lambda表达式中的变量 text 。 注意这个变量并不是在这个 lambda表达式中定义的。实际上，这是 repeatMessage 方法的一个参数变量。

如果再想想看，这里好像会有问题，尽管不那么明显。lambda 表达式的代码可能会在 repeatMessage 调用返回很久以后才运行，而那时这个参数变量已经不存在了。如何保留 text 变量呢？

要了解到底会发生什么，下面来巩固我们对 lambda 表达式的理解 lambda 表达式有 3 个部分：
1. 一个代码块；
1. 参数;
1. 自由变量的值，这是指非参数而且不在代码中定义的变量。

例子中，这个 lambda 表达式有 1 个自由变量 text。表示 lambda 表达式的数据结构必须存储自由变量的值，在这里就是字符串 "Hello"。我们说它被 lambda 表达式捕获（captured）。

**注释**：关于代码块以及自由变量值有一个术语： 闭包（closure）。 如果有人吹嘘他们的语言有闭包，现在你也可以自信地说 Java也有闭包。 在 Java 中， lambda表达式就是闭包。

可以看到，lambda 表达式可以捕获外围作用域中变量的值。在 Java 中，要确保所捕获的值是明确定义的，这里有一个重要的限制。在 lambda 表达式中，只能引用值不会改变的变量。例如， 下面的做法是不合法的：
```java
public static void countDown(int start, int delay) {
    ActionListener listener = event -> {
        // Local variable start defined in an enclosing scope must be final or effectively 
        start--;
 final
        System.out.println(start);
        Toolkit.getDefaultToolkit().beep();
    };
    new Timer(delay, listener).start();
}
```
之所以有这个限制是有原因的。如果在 lambda 表达式中改变变量，并发执行多个动作时就会不安全。对于目前为止我们看到的动作不会发生这种情况，不过一般来讲，这确实是一个严重的问题。

另外如果在 lambda表达式中引用变量， 而这个变量可能在外部改变，这也是不合法的。下面就是不合法的：
```java
public static void repeat(String text, int count) {
    for(int i = 1; i <= count; i++) {
        ActionListener listener = event -> {
            System.out.println(i + ":" + text);
            // Error: Cannot refer to changing i
        };
        new Timer(1000, listener).start();
    }
}
```
这里有一条规则：lambda 表达式中捕获的变量必须实际上是最终变量（effectively final)。