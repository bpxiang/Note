# 接口
>time: 2018-02-10 16:29:37  

## 1. 接口概念
在 Java程序设计语言中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。

我们经常听到服务提供商这样说: “如果类遵循了某个特定接口，那么久履行这项服务”。给出一个具体的示例。Arrays 类中的 sort 方法承诺可以对对象数组进行排序，但要求满足下列前提：对象所属的类必须实现了 Comparable接口。
```java
public interface Comparable {
    int compareTo(Object other);
}
// Java SE 5.0
public interface Comparable<T> {
    int compareTo(T other); // parameter has type T
}
```
这就是说， 任何实现 Comparable接口的类都需要包含 compareTo方法，并且这个方法的参数必须是一个 Object(Java SE 5.0 为 T) 对象， 返回一个整型数值。

接口中的所有方法自动地属于 public。 因此， 在接口中声明方法时， 不必提供关键字 public。在实现接口时，必须把方法声明为 public；否则，编译器将认为这个方法的访问属性是包可见性， 即类的默认访问属性，之后编译器就会给出试图提供更严格的访问权限的警告信息。

当然，接口中还有一个没有明确说明的附加要求：在调用 x.compareTo(y) 的时候，这个 compareTo 方法必须确实比较两个对象的内容， 并返回比较的结果。 当 x 小于 y 时， 返回一个负数；当 x 等于 y 时， 返回 0; 否则返回一个正数。

接口中还可以定义常。接口绝不能含有实例域。在 Java SE 8之前，不能在接口中实现方法。Java SE 8 及以后，可以在接口中提供简单方法，这些方法不能引用实例域——接口没有实例。

提供实例域和方法实现的任务应该由实现接口的那个类来完成。因此， 可以将接口看成
是没有实例域的抽象类。

假设希望使用 Arrays 类的 sort 方法对 Employee 对象数组进行排序， Employee 类就必须实现 Comparable 接口。  
为了让类实现一个接口，通常需要下面两个步骤：
1. 将类声明为实现给定的接口。
1. 对接口中的所有方法进行定义。

要将类声明为实现某个接口，需要使用关键字 implements：
```java
class Employee implements Comparable
```
这里的 Employee 类需要提供 compareTo 方法。 假设希望根据雇员的薪水进行比较。以下是 compareTo方法的实现:
```java
public class Employee implements Comparable {
@Override
    ...
    public int compareTo(Object otherObject) {
        Employee other = (Employee) otherObject;
        return Double.compare(salary, other.salary);
    }
}
// OR
public class Employee implements Comparable<Employee>{
    ...
    @Override
    public int compareTo(Employee other) {
        return Double.compare(salary, other.salary);
    }
}
```
在这里，我们使用了静态 Double.compare 方法， 如果第一个参数小于第二个参数，它会返回一个负值；如果二者相等则返回 0；否则返回一个正值。

要让一个类使用排序服务必须让它实现 compareTo 方法。这是理所当然的，因为要向 sort 方法提供对象的比较方式。但是为什么不能在 Employee 类直接提供一个 compareTo 方法，而必须实现 Comparable 接口呢？

主要原因在于 Java程序设计语言是一种强类型 （strongly typed) 语言。在调用方法的时候， 编译器将会检查这个方法是否存在。在 sort方法中可能存在下面这样的语句：
```java
if (a[i].compareTo(a[j]) > 0) {
    // rearrange a[i] and a[j]
    ...
}
```
为此， 编译器必须确认 a[i]—定有 compareTo 方法。 如果 a 是一个 Comparable 对象的数组， 就可以确保拥有 compareTo 方法，因为每个实现 Comparable 接口的类都必须提供这个方法的定义。

**注释：** 有人认为， 将 Arrays 类中的 sort 方法定义为接收一个 Comparable[] 数组就可以在使用元素类型没有实现 Comparable 接口的数组作为参数调用 sort 方法时，由编译器给出错误报告。但事实并非如此。 在这种情况下， sort 方法可以接收一个 Object[] 数组，并对其进行笨拙的类型转换：
```java
// Approach used in the standard library--not recommended
if (((Comparable) a[i]).compareTo(a[j]) > 0) {
    // rearrange a[i] and a[j]
    ...
}
```
如果 a[i] 不属于实现了 Comparable 接口的类， 那么虚拟机就会抛出一个异常。

### java.lang.Comparable<T> 1.0
* int compareTo(T other)
    >用这个对象与 other 进行比较。 如果这个对象小于 other 则返回负值； 如果相等则返回 0；否则返回正值。

### java.util.Arrays 1.2
* static void sort(Object[] a)
    >使用 mergesort 算法对数组 a 中的元素进行排序。要求数组中的元素必须属于实现了 Comparable 接口的类， 并且元素之间必须是可比较的。

### java.lang.lnteger 1.0
* static int comparedn(x , int y) 7
    >如果 x < y 返回一个负整数；如果 x 和 y 相等，则返回 0；否则返回一个负整数。
### java.lang.Double 1.0
* static int compare(double x , double y) 1.4
    >如果 x < y 返回一个负数；如果 x 和 y 相等则返回 0; 否则返回一个负数。

**注释：** 语言标准规定：对于任意的 x 和 y，实现必须能够保证 sgn(x.compareTo(y))=-sgn(y.compareTo(x))。（也就是说，如果 y.compareTo(x) 抛出一个异常，那么 x.compareTo(y) 也应该抛出一个异常。）这里的 “sgn” 是一个数值的符号： 如果 n 是负值，sgn(n) 等于 -1；如果 n 是 0，sgn(n) 等于 0；如果 n 是正值，sgn(n) 等于 1。简单地讲，如果调换 compareTo 的参数，结果的符号也应该调换（而不是实际值）。  
与 equals 方法一样，在继承的过程中有可能会出现问题。  
这是应为 Manager 扩展了 Employee，而 Employee 实现的是 Comparable<Employee>，而不是 Comparable<Manager>，如果 Manager 覆盖了 compareTo，就必须要有经理与雇员进行比较的思想准备，绝不能仅仅将雇员准换成经理。
```java
class Manager extends Employee {
    public int compareTo(Employee other) {
        Manager otherManager = (Manager) ohter; // NO
        ...
    }
    ...
}
```
这不符合“反对称”的规则。如果 x 是一个 Employee 对象，y 是一个 Manager 对象，调用 x.compareTo(x) 不会抛出异常，它只是将 x 和 y 都作为雇员进行比较。但是反过来，y.compareTo(x) 将会抛出一个 ClassCastException。

如果子类之间的比较含义不一样，那就属于不同类对象的非法比较。每个 compareTo 方法都应该在开始时候进行下列检测：
```java
if (getClass() != other.getClass) throw new ClassCastException);
```
如果存在这样一种通用算法，它能够对两个不同的子类对象进行比较，则应该在超类中提供一个 compareTo 方法，并将这个方法声明为 final。  
例如，假设不管薪水的多少都想让经理大于雇员，像 Executive 和 Secretary
 这样的子类又该则么办呢？如果一定要按照职务排列的话，那就应该在 Employee 类中提供一个 rank 方法。每个子覆盖 rank，并实现一个考虑 rank 值的 compareTo 方法。

 ## 2. 接口的特性

接口不是类，尤其不能使用 new 运算符实例化一个接口：  
`x = new Comparable(. . .); // ERROR`  
能声明接口的变量：  
`Comparable x; // OK`  
接口变量必须弓I用实现了接口的类对象：  
`x = new Employee(...); // OK provided Employee implements Comparable`  
如同使用 instanceof 检查一个对象是否属于某个特定类一样也可以使用
instance检查一个对象是否实现了某个特定的接口：  
`if (anObject instanceof Comparable) {...}`  
与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用
性的接口到较高专用性的接口的链。例如， 假设有一个称为 Moveable的接口：
