# 内部类
>time: 2018-03-01 15:21:33

内部类（inner class）是定义在另一个类中的类。

#### 需要内部类的主要原因：
1. 内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据。
1. 内部类可以对同一个包中的其他类隐藏起来。
1. 当想要定义一个回调函数且不想编写大量代码时，使用匿名 （anonymous) 内部类比较便捷。

内部类的对象有一个隐式引用，它引用了实例化改内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态。

在 Java 中，static 内部类没有这种附加指针。

## 1. 使用内部类访问对象状态

内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。内部类的对象总有一个隐式引用，它指向了创建它的外部类对象。

外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加一个外围类引用的参数。

只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。
```java
package core;

import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Date;

import javax.swing.JOptionPane;
import javax.swing.Timer;

public class InnerClassTest {

    public static void main(String[] args) {
        TalkingClock clock = new TalkingClock(1000, true);
        clock.start();
        
        // keep program running until user selects "Ok"
        JOptionPane.showMessageDialog(null, "Quit program?");
        System.exit(0);
    }
}

/**
 * A clock that prints the time in regular intervals.
 */
class TalkingClock {
    private int interval;
    private boolean beep;
    
    /**
     * Constructs a talking clock
     * @param interval the interval between messages (in milliseconds)
     * @param beep true if the clock should beep
     */
    public TalkingClock(int interval, boolean beep) {
        this.interval = interval;
        this.beep = beep;
    }
    
    /**
     * Starts the clock.
     */
    public void start() {
        ActionListener listener = new TimePrinter();
        Timer t = new Timer(interval, listener);
        t.start();
    }
    public class TimePrinter implements ActionListener {
        public void actionPerformed(ActionEvent event) {
            System.out.println("At the tone, the time is " + new Date());
            if (beep) Toolkit.getDefaultToolkit().beep();
        }
    }
}
```

## 2. 内部类的特殊语法规则

表达式  
`OuterClass.this`  
表示外围类引用。例如：
```java
public void actionPerformed(ActionEvent event) {
    ...
    if (TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep();
}
```

可以采用下列语法格式更加明确地编写内部对象的构造器：  
`outerObject.new InnerClass(construction parameters)`  
例：  
`ActionListener listener = this.new TimePrinter();`

在这里，最新构造的 TimePrinter 对象的外围类引用被设置为创建内部类对象的方法中的 this 引用。这是一种最常见的情况。通常，this 限定词是多余的。不过，可以通过显式地命名将外围类引用设置为其他的对象。例如，如果 TimePrinter 是一个公有内部类，对于任意的语音时钟都可以构造一个 TimePrinter：
```java
TalkingClock jabberer = new Talking(1000, true);
TalkingClock.TimePrinter listener = jabberer.new TimePrinter();
```
在外围类的作用域之外，可以这样引用内部类：  
`OuterClass.InnerClass`

注释：内部类声明的所有静态域都必须是 final。原因很简单。我们希望一个静态域只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例。如果这个域不是 final，它可能就不是唯一的。  
内部类不能有 static 方法。允许有静态方法，但只能访问外围类的静态域和方法。

## 3. 内部类是否有用、必要和安全
内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用 $(美元符号)分割外部类名与内部类名的常规类文件，而虚拟机对此一无所知。

将类 TalkingClock$TimePrinter 传递给它进行反射。也可以选择简单地使用 javap。  
`javap -private ClassName`

注释：如果使用 UNIX，并以命令行的方式提供类名，就需要记住将 $ 字符进行转义。也就是说，应该按照下面这种格式或 javap 程序运行 ReflectionTest 程序：  
`java reflection.ReflectionTest innerClass.TalkingClock\$TimePrinter`  
或
`javap -private innerClass.TalkingClock\$TimePrinter`


```
$ javap -private TalkingClock\$TimePrinter
Compiled from "InnerClassTest.java"
public class TalkingClock$TimePrinter implements java.awt.event.ActionListener {
  final TalkingClock this$0;
  public TalkingClock$TimePrinter(TalkingClock);
  public void actionPerformed(java.awt.event.ActionEvent);
}
```
内部类可以访问外围类的私有数据，可见，由于内部类拥有访问特权，所以与常规类比较起来功能更加强大。内部类如何管理那些额外的访问特权呢？利用査看一下 TalkingClock 类：
```
$ javap -private TalkingClock
Compiled from "InnerClassTest.java"
class TalkingClock {
  private int interval;
  private boolean beep;
  public TalkingClock(int, boolean);
  public void start();
  static boolean access$000(TalkingClock);
}
```
注意编译器在外围类添加静态方法 access$000。它将返回作为参数传递给它的对象域 beep。（方法名可能稍有不同，如 access$0，这取决于你的编译器）

总而言之，如果内部类访问了私有数据域，就有可能通过附加在外围类所在包中的其他类访问它们，但做这些事情需要高超的技巧和极大的决心。程序员不可能无意之中就获得对类的访问权限，而必须刻意地构建或修改类文件才有可能达到这个目的。

注释： 合成构造器和方法是复杂令人费解的。假设将 TimePrinter 转换为一个内部类。在虚拟机中不存在私有类，因此编译器将会利用私有构造器生成一个包可见的类：  
`private TalkingClock$TimePrinter(TalkingClock);`  
当然，没有人可以调用这个构造器，因此，存在第二个包可见构造器  
`TalkingClock$TimePriner(TalkingClock, TalkingClock$1);`  
它将调用第一个构造类。  
编译器将 TalkingClock 类 start 方法中的构造器调用翻译为：  
`new TalkingClock$TimePrinter(this, null)`

## 4. 局部内部类

```java
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Date;

import javax.swing.JOptionPane;
import javax.swing.Timer;

public class InnerClassTest {

    public static void main(String[] args) {
        TalkingClock clock = new TalkingClock(1000, true);
        
        clock.start();
        
        // keep program running until user selects "Ok"
        JOptionPane.showMessageDialog(null, "Quit program?");
        System.exit(0);
    }
}

/**
 * A clock that prints the time in regular intervals.
 */
class TalkingClock {
    private int interval;
    private boolean beep;
    
    /**
     * Constructs a talking clock
     * @param interval the interval between messages (in milliseconds)
     * @param beep true if the clock should beep
     */
    public TalkingClock(int interval, boolean beep) {
        this.interval = interval;
        this.beep = beep;
    }
    
    /**
     * Starts the clock.
     */
    public void start() {
        class TimePrinter implements ActionListener {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println("At the tone, the time is " + new Date());
                if(beep) Toolkit.getDefaultToolkit().beep();
            }
        };
        ActionListener listener = new TimePrinter();
        Timer t = new Timer(interval, listener);
        t.start();
    }
}
```

在 TalkingClock 实例代码中，TimePrinter 类名字只在 start 方法中创建这个类型的对象使用了一次。遇到这类情况时，可以在一个方法中定义局部类。

局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。

局部类有一个优势，即对外部世界可以完全地隐藏起来。即使 TalkingClock 类中的其他代码也不能访问它。除 start 方法之外，没有任何方法知道 TimePrinter 类的存在。

## 5. 由外部方法访问变量
局部类不仅能够访问包含它们的外部类，还可以访问局部变量。不过，那些局部变量必须事实上为 final。这说明，它们一旦赋值就绝不会改变。
```java
package core;

import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Date;

import javax.swing.JOptionPane;
import javax.swing.Timer;

public class InnerClassTest {

    public static void main(String[] args) {
        TalkingClock clock = new TalkingClock();
        clock.start(1000, true);
        
        // keep program running until user selects "Ok"
        JOptionPane.showMessageDialog(null, "Quit program?");
        System.exit(0);
    }
}

/**
 * A clock that prints the time in regular intervals.
 */
class TalkingClock {
    /**
     * Starts the clock.
     */
    public void start(int interval, boolean beep) {
        class TimePrinter implements ActionListener {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println("At the tone, the time is " + new Date());
                if(beep) Toolkit.getDefaultToolkit().beep();
            }
        };
        ActionListener listener = new TimePrinter();
        Timer t = new Timer(interval, listener);
        t.start();
    }
}
```
注意：TalkingClock 类不再需要存储实例变量 beep 了，它只是引用 start 方法中的 beep 参数变量。


