# 数学函数与常量

**floorMod** 方法的目的是解决一个长期存在的有关于整数余数的问题。考虑表达式 n % 2。如果 n 是偶数，这个表达式为 0；如果 n 是奇数，表达式为 1，如果 n 为负数，这个表达式则为 -1。为什么呢？设计最早的计算机时，必须有人制定规则，明确整数除法和求余对负数操作数该如何处理。数学家几百年来都知道这样一个最优（或“欧几里德”）规则： 余数总是要 `>=0`。不过，最早制定规则的人并没有翻开数学书好好研究，而是提出了一些看似合理但实际上很不方便的规则。

下面考虑这样一个问题： 计算一个时钟的指针位置。这里要做一个时间调整，而且要归一化为一个 `0 ~ 11` 之间的数。这很简单：`(position + adjustment) % 12`。不过，如果这个调整为负怎么样呢？你可能会得到一个负数。所以要引入一个分支，或者使用 `((position + adjustment) % 12 + 12) % 12`。不管怎么样，总之很麻烦。

floorMod 方法就让这个问题变得容易了： `floorMod(position + adjustment, 12)`总会得到一个 `0 ~ 11` 之间的数。（遗憾的是，对于负数，floorMod 会的负数的结果，不过这种情况在实际中很少出现。）

在 Math 类中，为了达到最快的性能，所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可预测的结果比运行速度更重要的话，那么就应该使用 StrictMath 类。它使用“自由发布的 Math 库”(fdlibm)实现算法，以确保在所有平台上得到相同的结果。
