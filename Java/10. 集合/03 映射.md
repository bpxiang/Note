# 映射
>time: 2018-06-28 16:04:56

集是一个集合，它可以快速地查找现有的元素。但是，要查看一个元素，需要有要查找元素的精确副本。这不是一种非常通用的査找方式。通常，我们知道某些键的信息，并想要查找与之对应的元素。

映射（map）数据结构就是为此设计的。映射用来存放键 / 值对。如果提供了键，就能够查找到值。

## 1. 基本映射操作
Java 类库为映射提供了两个通用的实现：HashMap 和 TreeMap。这两个类都实现了 Map 接口。

散列映射对键进行散列，树映射用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用域键。与键关联的值不能进行散列或比较。

散列稍快一些，如果不需要按照排列顺序访问键，就最好选择散列。

每当往映射中添加对象时，必须同时提供一个键。  
要想检索一个对象，必须使用一个键。  
如果在映射中没有与给定键对应的信息，get 将返回 null。  
null 返回值可能并不方便。有时可以有一个好的默认值，用作为映射中不存在的键。然后使用 getOrDefault 方法。
```java
Map<String, Integer> scores = ...;
// Gets 0 if the id is not present
int score = scores.getOrDefault(id, 0);
```
键必须是唯一的。不能对同一个键存放两个值。如果对同一个键两次调用 put 方法，第二个值就会取代第一个值。实际上，put 将返回用这个键参数存储的上一个值。  
remove 方法用于从映射中删除给定键对应的元素。size 方法用于返回映射中的元素数。  
要迭代处理映射的键和值，最容易的方法是使用 forEach 方法。可以提供一个接收键和值的 lambda 表达式。映射中的每一项会依序调用这个表达式。
```java
scores.forEach((k, v) ->
    System.out.println("key=" + key + ", value=" + v));
```

```java
public class PriorityQueueTest {

    public static void main(String[] args) {
        Map<String, Employee> staff = new HashMap<>();
        staff.put("144-25-5464", new Employee("Amy Lee"));
        staff.put("567-24-2546", new Employee("Harry Hacker"));
        staff.put("157-62-7935", new Employee("Cary Cooper"));
        staff.put("456-62-5527", new Employee("Francesca Cruz"));
        
        // print all entries
        System.out.println(staff);
        
        // remove an entry
        staff. remove("567-24-2546");
        
        // replace an entry
        staff.put("456-62-5527", new Employee("Francesca Hiller"));
        
        // look up a value
        System.out.println(staff.get("157-62-7935"));
        
        // iterate through all entries
        staff.forEach((k, v) ->
            System.out.println("key=" + k + ", value:" + v));
    }
}
```
#### 输出
```
{157-62-7935=[name=Cary Cooper, salary=0.0], 144-25-5464=[name=Amy Lee, salary=0.0], 456-62-5527=[name=Francesca Cruz, salary=0.0], 567-24-2546=[name=Harry Hacker, salary=0.0]}
[name=Cary Cooper, salary=0.0]
key=157-62-7935, value:[name=Cary Cooper, salary=0.0]
key=144-25-5464, value:[name=Amy Lee, salary=0.0]
key=456-62-5527, value:[name=Francesca Hiller, salary=0.0]
```

#### `java.util.Map<K, V> 1.2`
* V get(Object key)
    >获取与键对应的值；返回与键对应的对象，如果在映射中没有这个对象则返回 null。键可以为 null。
* default V getOfDefault(Object key, V defaultValue)
    >获得与键关联的值；返回与键关联的对象，或者如果未在映射中找到这个键，则返回 defaultValue。
* V put(K key, V value)
    >将键与对应的值关系插入到映射中。如果这个键已经存在，新的对象将取代与这个键对应的旧对象。这个方法将返回键对应的旧值。如果这个键以前没有出现过则返回null。键可以为 null，但值不能为 null。
* void putAll(Map<? extends K, ? extends V> entries)
    >将给定映射中的所有条目添加到这个映射中。
* boolean containsKey(Object key)
    >如果在映射中已经有这个键，返回 true。
* boolean containsValue(Object value)
    >如果映射中已经有这个值，返回 true。
* default void forEach(BiConsumber<? super K, ? super V> action) 8
    >对这个映射中的所有键/值对应用这个动作。

#### `java.util.HashMap<K, V> 1.2`
* HashMap()
* HashMaP(int initialCapacity)
* HashMap(int initialCapacity, float loadFactory)
    >用给定的容量和装填因子构造一个空散列映射（装填因子是一个 0.0 ~ 1.0 之间的数值。这个数值决定散列表填充的百分比。一旦到了这个比例，就要将其再散列到更大的表中）。默认的装填因子是 0.75。

#### `java.util.TreeMap<K, V> 1.2`
* TreeMap()
    >为实现 Comparable 接口的键构造一个空的映射树。
* TreeMap(Comparator<? super K> c)
    >构造一个映射树，并使用一个指定的比较器对键进行排序。
* TreeMap(Map<? extends K, ? extends V> c)
    >构造一个映射树，并将某个映射中的所有条目添加到映射中。
* TreeMap(SortedMap<? extends K, ? extends V> entries)
    >构造一个映射树，将某个有序映射中的所有条目添加到树映射中，并使用与给定的有序映射相同的比较器。

#### `java.util.SortedMap<K, V> 1.2`
* `Comparator<? super K> comparator()`
    >返回对键进行排序的比较器。如果键是用 Comparable 接口的 compareTo 方法进行比较的，返回 null。
* K firstKey()
* K lastKey()
    >返回映射中最小元素和最大元素。

## 2. 更新映射项
处理映射时的一个难点就是更新映射项。

例如，使用一个映射统计一个单词在文章中出现的频度。看到一个单词时，我们将计数器增 1:  
`counts.put(word, counts.get(word) + 1)`  
有一种情况，就是第一次看到 word 时。get 会返回 null，因此会出现一个 NullPointerException 异常。  
作为一个简单的补救，可以使用 getOrDefault 方法：  
`counts.put(word, counts.getOrDefault(word, 0) + 1)`  
另一种方法是首先调用 putIfAbsent 方法。只有当键原先存在时才会放入一个值。
```java
counts.putIfAbsent(word, 0);
// Now we know that get will succeed
counts.put(word, counts.get(word) + 1);
```
不过还可以做得更好。merge 方法可以简化这个常见的操作。如果键原先不存在，下面的调用：  
`counts.merge(word, 1, Integer::sum)`  
将把 word 与 1 关联，否则使用 Integer::sum 函数组合原值和 1（也就是将原值与 1 求和）。

#### `java.util.Map<K, V> 1.2`
* `default  V merae(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) 8`
    >如果 key 与一个非 null 值 v 关联，将函数应用到 v 和 value，将 key 与结果关联，或者如果结果为 null，则删除这个键。否则 将 key 与 value 关联，返回 get(key)。
* `default V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction>) 8`
    >将函数应用到 key 和 get(key)。将 key 与结果关联，或者如果结果为 null，则删除这个键。返回 get(key)。
* `default V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFuncton) 8`
    >如果 key 与一个非 null 值 v 关联，将函数应用到 key 和 v，将 key 与结果关联，或者如果结果为 null，则删除这个键。返回 get(key)。
* `default V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) 8`
    >将函数引用到 key，除非 key 与一个非 null 值关联。将 key 与结果关联，或者如果结果为 null，则删除这个键。返回 get(key)。
* `default void replaceAll(BiFunction<? super K, ? super V, ? extends V) function) 8`
    >在所有映射项上应用函数。将键与非 null 结果关联，对于 null 结果，则将相应的键删除。

## 3. 映射视图
集合框架不认为映射本身是一个集合。（其他数据结构框架认为映射是一个键/值对集合，或者由键索引的值集合。）不过，可以得到映射的视图（view）—— 这是实现了 Collection 接口或某个子接口的对象。

有 3 种视图：
1. 键集
1. 值集合（不是一个集）
1. 键/值对集

键和键/值对可以构成一个集，因为映射中一个键只能有一个副本。
```
Set<K> keySet()
Collection<V> values()
Set<Map.Entry<K, V>> entrySet()
```
会分别返回这 3 个视图。（条目集的元素是实现 Map.Entry 接口的类的对象。）

keySet 不是 HashSet 或 TreeSet，而是实现了 Set 接口的另外某个类的对象。Set 接口扩展了 Collection 接口。因此，可以像使用集合一样使用 keySet。

```java
Set<String> keys = map.keySet();
for(String key: keys) {
    // do something with key
}

for(Map.Entry<String, Employee> entry : staff.entrySet()) {
    String k = entry.getKey();
    Employee v = entry.getValue();
    // do something with k, v
}
```
***
**提示**：原先这是访问所有映射条目的最高效的方法。如今，只需要使用 forEach 方法：
```java
counts.forEach((k, v) -> {
    // do something with k, v
});
```
***
如果在键集视图上调用迭代器的 remove 方法，实际上会从映射中删除这个键和与它关联的值。不过，不能向键集视图增加元素。另外，如果增加一个键而没有同时增加值也是没有意义的。如果试图调用 add 方法，它会抛出一个 UnsupportedOperationException。条目集视图有同样的限制，尽管理论上增加一个新的键/值对好像是有意义的。

#### `java.util.Map<K, V> 1.2`
* `Set<Map.Entry<K, V>> entrySet()`
    >返回 Map.Entry 对象（映射中的键/值对）的一个集视图。可以从这个集中删除元素，它们将从映射中删除，但是不能增加任何元素。
* `Set<K> keySet()`
    >返回映射中所有键的一个集视图。可以从这个集中删除元素，键和相关联的值将从映射中删除，但是不能增加任何元素。
* `Collection<V> values()`
    >返回映射中所有值得一个集合视图。可以从这个集中删除元素，所删除的值及相应的键将从映射中删除。不过不能增加任何元素。

#### `java.util.Map.Entry<K, V> 1.2`
* K getKey()
* V getValue()
    >返回这一条目的键或值。
* V setValue(V newValue)
    >将相关映射中的值改为新值，并返回原来的值。

## 4. 弱散射映射

