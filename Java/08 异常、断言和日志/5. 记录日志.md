# 记录日志
>time: 2018-04-18 09:38:16

记录日志 API 的优点：
1. 可以很容易地取消全部日志记录，或者仅仅取消某个级别的日志，而且打开和关闭这个操作也很容易。
1. 可以很简单地禁止日志记录的输出，因此，将这些日志代码留在程序中的开销很小。
1. 日志记录可以被定向到不同的处理器，用于在控制台中显示，用于存储在文件中等。
1. 日志记录器和处理器都可以对记录进行过滤。过滤器可以根据过滤实现器制定的标准丢弃那些无用的记录项。
1. 日志记录可以采用不同的方式格式化，例如，纯文本或 XML。
1. 应用程序可以使用多个日志记录器，它们使用类似包名的这种具有层次结构的名字，例如， com.mycompany.myapp0
1. 在默认情况下，日志系统的配置由配置文件控制。如果需要的话，应用程序可以替换这个配置。

## 1. 基本日志
要生成简单的日志记录，可以使用全局日志记录器（global logger）并调用其 info 方法：  
`Logger.getGlobal().info("File->Open menu item selected");`  
在默认情况下，这条记录将会显示以下内容：
```
Apr 19, 2018 4:48:07 PM Test main
信息: File->Open menu item selected
```
但是，如果在适当的地方（如 main 开始）调用  
`Logger.getGlobal().setLevel(Level.OFF);`  
将会取消所有的日志。

## 2. 高级日志

从前面已经看到“虚拟日志”，下面继续看一下企业级（industrial-strength）日志。在一个专业的应用程序中，不要将所有的日志都记录到一个全局日志记录器，而是可以自定义日志记录器。

可以调用 getLogger 方法创建或获取记录器：  
`private static final Logger myLogger = Logger.getLogger("com.mycompany.myapp");`

***
**提示**： 未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，要像上面的例子中一样，用一个静态变量存储日志记录器的一个引用。
***

与包名类似，日志记录器名也具有层次结构。事实上，与包名相比，日志记录器的层次性更强。对于包来说，一个包的名字与其父包的名字之间没有语义关系，但是日志记录器的父与子之间将共享某些属性。例如，如果对 `com.mycompany` 日志记录器设置了日志级别，它的子记录器也会继承这个级别。

通常，有以下 7 个日志记录器级别：
* SERVER
* VARNING
* INFO
* CONFIG
* FINE
* FINER
* FINEST

在默认情况下，只记录前三个级别。也可以设置其他的级别。例如，  
`logger.setLevel(Level.FINE);`  
FINE 和更高级别的记录都可以记录下来。  
可以使用 Level.ALL 开启所有级别的记录，或者使用 Level.OFF 关闭所有级别的记录。

对于所有的级别有下面几种记录方法：  
```java
logger.warning(message);
logger.fine(message);
```

还可以使用 log 方法指定级别，例如  
`logger.log(Level.FINE, message);`

***
**提示**： 默认的日志配置记录了 INFO 或更高级别的所有记录，因此，应该使用 CONFIG、 FINE 和 FINEST 级别来记录那些有助于诊断，但对于程序员又没有太大意义的调试信息。
***

***
**警告**： 如果将记录级别设置为 INFO 或者更低，则需要修改日志处理器的配置。默认的日志处理器不会处理低于 INFO 级别的信息。
***

默认的日志记录将显示包含日志调用的类名和方法名，如同堆栈所显示的那样。但是，如果虚拟机对执行过程进行了优化，就得不到准确的调用信息。此时，可以调用 logp 方法获得调用类和方法的确切位置，这个方法的签名为：  
`void logp(Level l, String className, String nethodName, String message)`  
下面有一些用来跟踪执行流的方法：
```java
void entering(String className, String methodName)
void entering(String className, String methodName, Object param)
void entering(String className, String methodName, Object[] param)
void exiting(String className, String methodName)
void exiting(String className, String methodName, Object result)
```

```java
private static final Logger logger = Logger.getLogger("com.mycompany.myapp");

int read(String file, String pattern) {
    int count = 0;
    logger.entering("com.mycompany.mylib.Reader", "read",
            new Object[]{file, pattern});
    
    logger.exiting("com.mycompany.mylib.Reader", "read", count);
    return count;
}
```
这些调用将生成 FINER 级别和以字符串 ENTRY 和 RETURN 开始的日志记录。

***
注释： 在未来，带 Object[] 参数的日志记录方法可能会被重写，以便支持变量参数列表(“varargs”)。此后就可以用 `logger.entering("com.mycompnay.mylib.Reader", "read", file, pattern)` 格式调用这个方法了。
***

记录日志的常见用途是记录那些不可预料的异常，可以使用下面两个方法提供日志记录中包含的异常描述内容。
```java
void throwing(String className, String methodName, Throwable t)
void log(Level l, String message, Throwale t)
```
典型的用法：

```java
if(...) {
    IOException exception = new IOException("...");
    logger.throwing("com.mycompany.mylib.Reader" , "read", exception);
    throw exception;
}
```

```java
try {
    ...
} catch (IOException e) 
{
    Logger.getLogger("com.mycompany.myapp").log(Level.WARNING, "Reading image", e);
}
```

调用 throwing 可以记录一条 FINER 级别的记录和一条以 THROW 开始的信息。

## 3. 修改日志管理器配置
可以通过编辑配置文件来修改日志系统的各种属性。在默认情况下，配置文件存在于：  
`jre/lib/logging.properties`  
要想使用另一个配置文件，就要将 `java.util.logging.config.file` 特性设置为配置文件的存储位置，并用下列命令启动应用程序:  
`java -Djava.util.logging.config.file=configFile MainClass`

***
**警告**：日志管理器在 VM 启动过程中初始化，这在 main 执行之前完成，如果在 main 中调用 `System.setProperty("java.util.logging.config.file", file)`，也会调用 LogManager.readConfiguration() 来重新初始化日志管理器。
***

要想修改默认的日志记录级别，就需要编辑配置文件，并修改以下命令行  
`.level=INFO`  
可以通过添加以下内容来指定自己的日志记录级别  
`com.mycompany.myapp=FINE`  
在日志记录器名后面添加后缀 `.level`。

日志记录并不将消息发送到控制台上，这是处理器的任务。另外，处理器也有级别。想要在控制台上看到 `FINE` 级别的消息，就需要进行下列设置  
`java.util.logging.ConsoleHandler.level=FINE`

***
**警告**： 在日志管理器配置的属性设置不是系统属性，因此，用 `-Dcom.mycompany.myapp.level=FINE` 启动应用程序不会对日志记录器产生任何影响。
***
**警告**：截止到 Java SE 7，Logmanager 类的 API 注释主张通过 Preferences API 设置 `java.util.logging.config.class` 和 `java.util.logging.config.file` 属性。这是不正确的。
***
**警告**：日志属性文件由 `java.util.logging.LogManager` 类处理。可以通过将 `java.util.logging.manager` 系统属性设置为某个子类的名字来指定一个不同的日志管理器。另外，在保存标准日志管理器的同时，还可以从日志属性文件跳过初始化。还有一种方式是将 `java.util.logging.config.class` 系统属性设置为某个类名，该类再通过其他方式设定日志管理器属性。
***

在运行的程序中，使用 jconsole 程序也可以改变日志记录的级别。有关信息请参看[www.oracle.com/technetwork/articles/java/jconsole-1564139.html#LoggingControl](http://www.oracle.com/technetwork/articles/java/jconsole-1564139.html#LoggingControl)。

## 4.本地化
将日志消息本地化，以便让全球的用户都可以阅读它。

本地化的应用程序包资源包（resource bundle）中的本地特征信息。资源包有各个地区的映射集合组成。例如，某个资源包可能将字符串“readingFile”映射成英文的“Reading file”或者德文“Achtung! Datei wird eingelesen”。

一个程序可以包含多个资源包，一个用于菜单；其他用于日志消息。每个资源包都有一名字（如，com.mycompany.logmessages）。要想将映射添加到一个资源包中，需要为每个地区创建一个文件。英文消息映射位于 `com/mycompany/logmessages_en.properties` 文件中；德文消息映射位于 `com/mycompany/logmessages_de.properties` 文件中。可以将这些文件与应用程序的类文件放在一起，以便 ResourceBundle 类自动地对它们进行定位。这些文件都是纯文本文件，其组成如下所示：
```
readingFile=Achtung! Datei wird eingelesen
renamingFile=Datei wird umbenannt
```
在请求日志记录器时，可以指定一个资源包：  
`Logger logger = Logger.getLogger(loggerName, "com.mycompany.logmessages");`  
然后，为日志消息指定资源包的关键字，而不是实际的日志消息字符串。   
`logger.info("readingFile");`  
通常需要在本地化的消息中增加一些参数，因此，消息应该包括占位符 {0}、{1} 等。例如，要想在日志消息中包含文件名，就应该用下列方式包括占位符：  
```
Reading file {0}.
Achtung! Datei {0} wird eingelesen.
```
然后，通过调用下面的一个方法向占位符传递具体的值：  
```java
logger.log(Level.INFO, "readingFile", fileName);
logger.log(Level.INFO, "renamingFile", new Object[]{oldName, newName});
```

## 5. 处理器
在默认情况下，日志记录器将记录发送到 ConsoleHandle 中，并由它输出到 System.err 流中。特别是，日志记录器还会将记录发送到父处理器中，而最终的处理器（命名为“”）有一个 ConsoleHandler。

与日志记录器一样，处理器也有日志记录级别。对于一个要被记录的日志记录，它的日志记录级别必须高于日志记录器和处理器的阈值。日志管理器配置文件设置的默认控制台处理器的日志记录级别为  
`java.util.logging.ConsoleHandler.level=INFO`  
要想记录 FINE 级别的日志，就必须修改配置文件中的默认日志记录级别和处理器级别。另外，还可以绕过配置文件，安装自己的处理器。

```java
Logger logger = Logger.getLogger("com.mycompany.myapp");
logger.setLevel(Level.FINE);
logger.setUseParentHandlers(false);
Handler handler = new ConsoleHandler();
handler.setLevel(Level.FINE);
logger.addHandler(handler);
logger.fine("com.mycompany.myapp.fine");
```
在默认情况下，日志记录器将记录发送到自己的处理器和父处理器。我们的日志记录