# 捕获异常
>time: 2018-03-14 14:34:53

## 1. 捕获异常
如果某个异常发生的时候没有任何地方进行捕获，那程序就会终止执行，并在控制台当打印出异常信息，其中包括异常的类型和堆栈的内容。对于图形界面程序（applet 和应用程序），在捕获异常之后，也会打印出堆桟的信息，但程序将返回到用户界面的处理循环中(在调试 GUI 程序时，最好保证控制台窗口可见，并且没有被最小化）。

捕获一个异常，必须设置 try/catch 语句块。
```java
try {
    code
    more code
    more code
} catch (Exception e) {
    handler for this type
}
```

如果在 try 语句块中的任何代码抛出了一个在 catch 子句中说明的异常类，那么
1. 程序将跳过 try语句块的其余代码。
1. 程序将执行 catch 子句中的处理器代码。

如果在 try 语句块中的代码没有拋出任何异常，那么程序将跳过 catch 子句。  
如果方法中的任何代码拋出了一个在 catch 子句中没有声明的异常类型，那么这个方法就会立刻退出（希望调用者为这种类型的异常设了 catch 子句)。
```java
public void read(String filename) {
    try {
        ImputStream in = new FileInputStream(filename);
        int b;
        while ((b = in.read()) != -1) {
            process input
        } catch (IOException exception) {
            exception.printStackTrace();
        }
    }
}
```

需要注意的是，try 语句中的大多数代码都很容易理解：读取并处理字节，直到遇到文件终止符为止。正如在 Java API 中看到的那样，read  方法有可能抛出一个 IOException 异常。在这种情况下，将跳出整个 while 循环，进入 catch 字句，并生成一个栈轨迹。对于一个普通的程序来说，这样处理异常基本上合乎情理。还有其他的选择吗？  
通常最好的选择是什么也不做，而是将异常传递给调用者。如果 read 方法出现了错误，就让 read 方法的调用者去操心！如果采用这种处理方式，就必须声明这个方法可能抛出一个 IOException。
```java
public void read(String  filename) throws IOException {
    InputStream in = new FileInputStream(filename);
    int b;
    while ((b = in.read()) != -1) {
        process input
    }
}
```
请记住，编译器严格地执行 throws 说明符。如果调用了一个抛出受查异常的方法，就必须对它进行处理，或者继续传递。  
哪种方法更好呢？通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续进行传递。  
如果想传递一个异常，就必须在方法的首部添加一个 throws 说明符，以便告知调用者这个方法可能会抛出异常。

仔细阅读一下 Java API 文档，以便知道每个方法可能会抛出哪种异常，然后再决定是自己处理，还是添加到 throws 列表中。对于后一种情况，也不必犹豫。将异常直接交给能胜任的处理器进行处理要比压制对它的处理更好。

同时请记住，这个规则也有一个例外，前面曾经提到过： 如果编写一个覆盖超类的方法，而这个方法有没有抛出异常（如 JComponent 中的 paintComponent），那么这个方法就必须捕获方法代码中出现的每一个受查异常。不允许在子类的 throws 说明符中出现超类方法所列出的异常类范围。

## 2. 捕获多个异常
在一个 try 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。可以按照下列方式为每个异常类型使用一个单独的 catch 子句：
```java
try {
    code that might throw exceptions
} catch (FileNotFoundException e) {
    emergency action for missing files
} catch (UnknownHostException e) {
    emergency action for unknown hosts
} catch (IOException e) {
    emergency action for all other I/O problems
}
```
异常对象可能包含与异常本身有关的信息。要想获得对象的更多信息，可以试着使用  
`e.getMessage()`  
得到详细的错误信息（如果有的话），或者使用  
`e.getClass().getName()`  
得到异常对象的实际类型。

在 Java SE 7 中，同一个 catch 子句中可以捕获多个异常类型。
```java
try {
    code that might throw exception
} catch(FileNotFoundException | UnknownHostException e) {
    emergency action for missing files and unknown hosts
} catch(IOException e) {
    emergency action for all other I/O problems
}
```
只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性。

**注释**： 捕获多个异常时，异常变量隐含为 final 变量。例如，不能再一下子句中为 e 赋不同的值：  
`catch (FileNotFoundException | UnknowHostException e) {...}`

**注释**： 捕获多个异常不仅会让你的代码看起来更简单，还会更高效。生成的字节码只包含一个对应公共 catch 子句的代码块。

## 3. 再次抛出异常与异常链

在 catch 子句中可以抛出一个异常，这样做的目的是改变异常的类型。如果开发了一个供其他程序员使用了子系统，那么，用于表示子系统故障的异常类型可能会产生多种解释。ServletException 就是这样一个异常类型的例子。执行 servlet 的代码可能不想知道发生错误的细节原因，但希望明确地知道 servlet 是否有问题。  
捕获异常并将它再次抛出的基本方法：
```java
try {
    access the database
} catch(SQLException e) {
    throw new ServletException("database error: " + e.getMessage());
}
```
这里，ServleException 用带有异常信息文本的构造器来构造。  
不过，可以有一种更好的处理方法，并且将原始异常设置为新异常的“原因”：  
```java
try{
    access the database
} catch (SQLException e) {
    Throwable se = new ServletException("database error");
    se.initCause(e);
    throw se;
}
```
当捕获到异常时， 就可以使用下面这条语句重新得到原始异常：  
`Throwable e = se.getCause();`  
强烈建议使用这种包装技术。这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。

**提示**： 如果在一个方法中发生了一个受查异常，而不允许抛出它，那么包装技术就十分有用。我们可以捕获这个受查异常， 并将它包装成一个运行时异常。

有时你可能只想记录一个异常， 再将它重新抛出， 而不做任何改变：
```java
try {
    access the database
} catch(Exception e) {
    logger.log(level, message, e);
    throw e;
}
```
在 Java SE 7 之前，这种方法存在一个问题。假设这个代码在以下方法中：  
`public void updateRecord() throws SQLException`  
Java 编译器查看 catch 块中的 throw 语句，然后查看 e 的类型，会指出这个方法可以抛出任何 Exception 而不只是 SQLException。现在这个问题已经有所改进。编译器会跟踪到 e 来自 try 块。假设这个 try 块中仅有的已检查异常是 SQLException 实例，另外，假设 e 在 catch 块中未改变，将外围方法声明为 throws SQLException 就是合法的。

## 4. finally 子句
当代码抛出一个异常时， 就会终止方法中剩余代码的处理，并退出这个方法的执行。 如果方法获得了一些本地资源，并且只有这个方法自己知道，又如果这些资源在退出方法之前必须被回收，那么就会产生资源回收问题。一种解决方案是捕获并重新抛出所有的异常。但是，这种解决方案比较乏味，这是因为需要在两个地方清除所分配的资源。一个在正常的代码中；另一个在异常代码中。Java有一种更好的解决方案，这就是 finally 子句。

不管是否有异常被捕获， finally 子句中的代码都被执行。
```java
InputStream in = new FileInputStream(...);
try {
    // 1
    code that might throw exception
    // 2
} catch (IOException e) {
    //  3
    show error message
    // 4
} finally {
    // 5
    in.close();
}
// 6
```
在上面这段代码中，有下列 3 种情况会执行 finally 子句：
1. 代码没有抛出异常。在这种情况下，程序首先执行 try 语句块中的全部代码，然后执 finally 子句中的代码。随后，继续执行 try 语句块之后的第一条语句。也就是说，执行标注的 1、 2、 5、 6 处。

2. 抛出一个在 catch 子句中捕获的异常。在上面的示例中就是 IOException 异常。在这种情况下，程序将执行 try 语句块中的所有代码，直到发生异常为止。此时，将跳过 try 语句块中的剩余代码，转去执行与该异常匹配的 catch 子句中的代码，最后执行 finally 子句中的代码。
    1. 如果 catch子句没有抛出异常，程序将执行 try 语句块之后的第一条语句。在这里，执行标注 1、 3、 4、5、 6处的语句。
    1. 如果 catch 子句抛出了一个异常，异常将被抛回这个方法的调用者。在这里， 执行标注 1、3、5 处的语句。

1. 代码抛出了一个异常，但这个异常不是由 catch 子句捕获的。在这种情况下，程序将执行 try 语句块中的所有语句，直到有异常被抛出为止。此时，将跳过 try 语句块中的剩余代码，然后执行 finally 子句中的语句，并将异常抛给这个方法的调用者。在这里，执行标注 1、5 处的语句。

```java
InputStream in = ...;
try {
    code that might throw exception
} finally {
    in.close();
}
```
无论在 try 语句块中是否遇到异常， finally 子句中的 in.close() 语句都会被执行。当然，如果真的遇到一个异常，这个异常将会被重新抛出，并且必须由另一个 catch 子句捕获。  
事实上， 我们认为在需要关闭资源时， 用这种方式使用 finally 子句是一种不错的选择。

***
**提示**： 这里，强烈建议解搞合 try/catch 和 try/finally 语句块。 这样可以提高代码的清晰度。例如：
```java
InputStream in = ...;
try {
    try {
        code that might throw exception
    } finally {
        in.close();
    }
} catch (IOException e) {
    show error message
}
```
内层的 try 语句块只有一个职责，就是确保关闭输入流。 外层的 try 语句块也只有一个职责，就是确保报告出现的错误。这种设计方式不仅清楚，而且还具有一个功能，就是将会报告 finally 子句中出现的错误。
***

**警告**： 当 finally 子句包含 return 语句时，将会出现一种意想不到的结果。假设利用 return 语句从 try 语句块中退出。在方法返回前，finally 子句的内容将被执行。如果 finally 子句中也有一个 return 语句， 这个返回值将会覆盖原始的返回值。请看一个复杂的例子：