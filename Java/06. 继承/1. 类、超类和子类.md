# 类、超类和子类
>time: 2017-12-18 16:58:12

 “is-a” 关系是继承的一个明显特征。

## 1. 定义子类

关键字 extends 表示继承。
```java
public class Manager extends Employee
{
    ...
}
```
在 Java 中，所有的继承都是公有继承。

关键字 extends 表明正在构造的新类派生于一个已存在的类。已存在的类称为超类（superclass）、基类（base class）或父类（parent class）；新类称为子类（subclass）、派生类（derived class）或孩子类（child class）。超类和子类是 Java 程序员最常用的两个术语，而了解其他语言的程序员可能更加偏爱使用父类和孩子类，这些都是继承时使用得术语。

尽管 Employee 类是一个超类，但并不是因为它优于子类或者拥有比子类更多的功能。实际上恰恰相反 ，子类比超类拥有的功能更加丰富。例如，读过 Manager 类的源代码之后就会发现， Manager 类比超类 Employee 封装了更多的数据，拥有更多的功能。

注释： 前缀 “超” 和 “子” 来源于计算机科学和数学理论中的集合语言的术语。所有雇员组成的集合包含所有经理组成的集合。可以这样说，雇员集合是经理集合的超集，也可以说， 经理集合是雇员集合的子集。

在 Manager 类中 ，增加了一个用于存储奖金信息的域 ，以及一个用于设置这个域的新方法 ：
```java
public class Manager extends Employee
{
    private double bonus;
    ...
    public void setBonus(double bonus)
    {
        this.bonus = bonus;
    }
}
```

这里定义的方法和域并没有什么特别之处。如果有一个 Manager 对象，就可以使用 setBonus 方法。
```java
Manager boss = ...;
boss.setBonus(5000);
```

当然，由于 setBonus 方法不是在 Employee 类中定义的 ， 所以属于 Employee 类的对象不能使用它。

然而， 尽管在 Manager 类中没有显式地定义 getName 和 getHireDay 等方法， 但属于Manager 类的对象却可以使用它们 ， 这是因为 Manager 类自动地继承了超类 Employee 中的这些方法。

同样，从超类中还继承了 name、 salary 和 hireDay 这 3 个域。这样一来， 每个 Manager 类对象就包含了 4个域： name、 salary 、 hireDay 和 bonus。

在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中，这种将通用的功能放到超类的做法，在面向对象程序设计中十分普遍。

## 2. 覆盖方法
子类的方法不能直接访问超类的私有域。如果一定要访问私有域，就必须借助于公有的接口，使用特定的关键字 super。

```java
public double getSalary() {
    double baseSalary = super.getSalary();
    return baseSalay + bonus;
}
```

注释：有些人认为 super 与 this 引用是类似的概念，实际上，这样比较并不恰当。这是因为 super 不是一个对象的引用，不能讲 super 赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。

## 3. 子类构造器
```java
public Manager(String name, double salary, int year, int month, int day)
{
    super(name, salary, year, month, day);
    bonus = 0;
}
```
这里的关键字 super 具有不同的含义。语句
```java
super(n, s, year, month, day);
```
是“ 调用超类中含有 n、 s、year month和 day参数的构造器” 的简写形式。

如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数 )的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类
的其他构造器，则 Java 编译器将报告错误。

### this有两个用途
* 引用隐式参数
* 调用该类其他的构造器

### super 关键字也有两个用途
* 调用超类的方法
* 调用超类的构造器

一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。

在 Java 中，不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征，可以将它标记为 final。

## 4. 继承层次

继承并不仅限于一个层次。由一个公共超类派生出来的所有类的集合被称为继承层次（inheritance hierarchy），在继承层次中，从某种特定的类到其祖先的路径称为该类的继承链(inheritance chain)。

通常， 一个祖先类可以拥有多个子孙继承链。

Java 不支持多继承。

## 5. 多态

有一个用来判断是否应该设计为继承关系的简单规则， 这就是 “is-a” 规则， 它表明子类的每个对象也是超类的对象。

“is-a” 规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以
用子类对象置换。

```java
Employee e;
e = new Employee(...); // Employee object expected
e = new Manager(...); // OK, Manager can be used as well
```

在 Java 程序设计语言中， 对象变量是多态的。

在 Java 中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。例如，下面是一个经理数组
```java
Manager[] managers = new Manager[10];
```
将它转换成 Employee[] 数组完全是合法的：
```java
EmployeeQ staff = managers; // OK
```
这样做肯定不会有问题，请思考一下其中的缘由。毕竟，如果 manager[i] 是一个Manager, 也一定是一个 Employee。 然而， 实际上， 将会发生一些令人惊讶的事情。要切记 managers和 staff 引用的是同一个数组。现在看一下这条语句：
```java
staff[0] = new Employee("Harry Hacker", . . .);
```
编译器竟然接纳了这个赋值操作。但在这里，stafflO] 与 manager[0] 引用的是同一个对象， 似乎我们把一个普通雇员擅自归入经理行列中了。 这是一种很忌伟发生的情形，当调用 managers[0].setBonus(1000) 的时候， 将会导致调用一个不存在的实例域， 进而搅乱相邻存储空间的内容。

为了确保不发生这类错误，所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。例如，使用 new managers[10] 创建的数组是一个经理数组。
如果试图存储一个 Employee类型的引用就会引发 ArrayStoreException 异常。

## 6. 理解方法调用

弄清楚如何在对象上应用方法调用非常重要。下面假设要调用 x.f(args)，隐式参数 x 声明为类 C 的一个对象。下面是调用过程的详细描述：
1. 编译器査看对象的声明类型和方法名。假设调用 x.f(param，) 且隐式参数 x 声明为 C 类的对象。需要注意的是：有可能存在多个名字为 f，但参数类型不一样的方法。例如，可能存在方法 f(int) 和方法 f(String)。编译器将会一一列举所有 C 类中名为 f 的方法和其超类中访问属性为 public 且名为 f 的方法（超类的私有方法不可访问）。

    至此， 编译器已获得所有可能被调用的候选方法。
    
1. 接下来，编译器将査看调用方法时提供的参数类型。如果在所有名为 f 的方法中存在
一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重栽解析（ overloading resolution)。

    由于允许类型转换，所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法， 或者发现经过类型转换后有多个方法与之匹配， 就会报告一个错误。

    至此，编译器已获得需要调用的方法名字和参数类型。

1. 如果是 private 方法、 static 方法、 final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定（static binding )。与此对应的是，调用的方法依赖于隐式参数的实际类型， 并且在运行时实现动态绑定。

1. 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与 x 所引用对象的实
际类型最合适的那个类的方法。假设 x 的实际类型是 D，它是 C 类的子类。如果 D 类定义了方法 f(String)，就直接调用它；否则， 将在 D 类的超类中寻找 f(String，) 以此类推。

方法的名字和参数列表称为方法的签名。如果在子类中定义了一个与超类签名相同的方
法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。  
不过，返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。

每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表(method table)，其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。在前面的例子中，虚拟机搜索 D 类的方法表，以便寻找与调用 f(Sting) 相匹配的方法。这个方法既有可能是 D.f(String), 也有可能是 X.f(String)，这里的 X 是 D 的超类。这里需要提醒一点，如果调用 super.f(param)，编译器将对隐式参数超类的方法表进行搜索。

### Employee 的方法表中
```
Employee:
    getName() -> Employee.getNameO
    getSalary() -> Employee.getSalaryO
    getHireDay() -> Employee.getHireDayO
    raiseSalary(double) -> Employee.raiseSalary(double)
```

### Manager 方法表
```
Manager:
    getNam() -> Employee.getNameO
    getSalary() -> Manager.getSalary0
    getHireDay() -> Employee.getHireDayO
    raiseSalary(double) -> Employee.raiseSalary(double)
    setBonus(double) -> Manager.setBonus(double)
```
### 在运行时， 调用 e.getSalary() 的解析过程为：
1. 首先， 虚拟机提取 e 的实际类型的方法表。既可能是 Employee、 Manager 的方法表，也可能是 Employee 类的其他子类的方法表。
1. 接下来，虚拟机搜索定义 getSalary 签名的类。此时，虚拟机已经知道应该调用哪个
方法。
1. 最后，虚拟机调用方法。

动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。假设增加一个新类 Executive, 并且变量 e 有可能引用这个类的对象，我们不需要对包含调用 e.getSalary() 的代码进行重新编译。如果 e 恰好引用一个 Executive 类的对象，就会自动地调用 Executive.getSalary() 方法。

警告：在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是 public, 子类方法一定要声明为 public。经常会发生这类错误：在声明子类方法的时候，遗漏了 public 修饰符。此时，编译器将会把它解释为试图提供更严格的访问权限。

## 7. 阻止继承：final 类和方法

不允许扩展的类被称为 final 类。如果在定义类的时候使用了 final 修饰符就表明这个类是 final 类。
```java
public final class Executive extends Manager
{
    ...
}
```

类中的特定方法也可以被声明为 final。 如果这样做，子类就不能覆盖这个方法（final 类中的所有方法自动地成为 final 方法）。
```java
public class Employee
{
    ...
    public final String getName()
    {
        return name;
    }
    ...
}
```

前面曾经说过，域也可以被声明为 final。对于 final 域来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为 final，只有其中的方法自动地成为 final，而不包括域。

将方法或类声明为 final 主要目的是： 确保它们不会在子类中改变语义。String 类也是 final 类，这意味着不允许任何人定义 String 的子类。换言之， 如果有一个 String 的引用，它引用的一定是一个 String 对象，而不可能是其他类的对象。

有些程序员认为： 除非有足够的理由使用多态性，应该将所有的方法都声明为 final。事实上，在 C++ 和 C# 中，如果没有特别地说明，所有的方法都不具有多态性。这两种做法可能都有些偏激。我们提倡在设计类层次时，仔细地思考应该将哪些方法和类声明为 final。

在早期的 Java 中，有些程序员为了避免动态绑定带来的系统开销而使用 final 关键字。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理， 这个过程为称为内联(inlining)。例如，内联调用 e.getName() 将被替换为访问 e.name 域。这是一项很有意义的改进，这是由于 CPU 在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略，所以，这被视为不受欢迎的。然而，如果 getName 在另外一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。

幸运的是，虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出类中是否真正地存在覆盖给定的方法。 如果方法很简短、被频繁调用且没有真正地被覆盖，那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖，那么将会发生什么情况呢？优化器将取消对覆盖方法的内联。这个过程很慢，但却很少发生。

## 8. 强制类型转换

将一个类型强制转换成另外一个类型的过程被称为类型转换。Java 程序设计语言提供了一种专门用于进行类型转换的表示法。

```java
double x = 3.405;
int nx = (int) x;
```
将表达式 x 的值转换成整数类型，舍弃了小数部分。

正像有时候需要将浮点型数值转换成整型数值一样，有时候也可能需要将某个类的对象
引用转换成另外一个类的对象引用。对象引用的转换语法与数值表达式的类型转换类似， 仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。
```java
Manager boss = (Manager) staff[0];
```
进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。

在 Java中，每个对象变量都属于一个类型。类型描述了这个变量所引用的以及能够引用的对象类型。

将一个值存人变量时，编译器将检查是否允许该操作。将一个了类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检査。

如果试图在继承链上进行向下的类型转换，并且 “谎报” 有关对象包含的内容，会发生
什么情况呢？
```java
Manager boss = (Manager) staff[1] ; // Error
```
运行这个程序时，Java运行时系统将报告这个错误，并产生一个 lassCastException 异常。如果没有捕获这个异常，那么程序就会终止。因此，应该养成这样一个良好的程序设计习惯：在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用 instanceof 操作符就可以实现。 例如：
```java
if(staff[1] instanceof Manager) {
    boss = (Manager) staff[1];
    ...
}
```

最后，如果这个类型转换不可能成功，编译器就不会进行这个转换。例如，下面这个类型转换：
```java
String c = (String) staff[1];
```
将会产生编译错误，这是因为 String 不是 Employee 的子类。  
综上所述:
* 只能在继承层次内进行类型转换。
* 在将超类转换成子类之前，应该使用 instanceof 进行检查。

如果 x 为 null，进行下列测试 `x instanceof C`，不会产生异常，只是返回 false。之所以这样处理是因为 null 没有引用任何对象，当然也不会引用 C 类型的对象。

实际上，通过类型转换调整对象的类型并不是一种好的做法。在我们列举的示例中，大多数情况并不需要将 Employee 对象转换成 Manager 对象，两个类的对象都能够正确地调用 getSalary 方法，这是因为实现多态性的动态绑定机制能够自动地找到相应的方法。

只有在使用 Manager 中特有的方法时才需要进行类型转换，例如，setBonus方法。如果鉴于某种原因，发现需要通过 Employee 对象调用 setBonus 方法，那么就应该检查一下超类的设计是否合理。重新设计一下超类，并添加 setBonus 方法才是正确的选择。请记住，只要没有捕获 ClassCastException 异常，程序就会终止执行。 在一般情况下，应该尽量少用类型转换和 instanceof 运算符。

## 9. 抽象类

如果自下而上在类的继承层次结构中上移，位于上层的类更具有通用性，甚至可能更加
抽象。从某种角度看，祖先类更加通用，人们只将它作为派生其他类的基类，而不作为想使用的特定的实例类。

为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。
```java
public abstract class Person
{
    ...
    public abstract String getDescription();
}
```
除了抽象方法之外，抽象类还可以包含具体数据和具体方法。
```java
public abstract class Person
{
    private String name;
    public Person(String name)
    {
        this.name = name;
    }

    public abstract String getDescription();

    public String getName(){
        return name;
    }
}
```

提示：许多程序员认为，在抽象类中不能包含具体方法。建议尽量将通用的域和方法（不
管是否是抽象的）放在超类（不管是否是抽象类）中。

抽象方法充当着占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择。
1. 是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；
1. 是定义全部的抽象方法，这样一来，子类就不是抽象的了。

类即使不含抽象方法，也可以将类声明为抽象类。  
抽象类不能被实例化。也就是说，如果将一个类声明为 abstract，就不能创建这个类的对象。  
可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。  
编译器只允许调用在类中声明的方法。

## 10. 受保护访问

在有些时候，人们希望超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域。为此，需要将这些方法或域声明为 protected。

父类中定义了 protected 的域 name；子类中的方法就可以直接地访问它。  
不过，子类中的方法只能访问子类对象中的 name 域，而不能访问父类对象中的 name 域。这种限制有助于避免滥用保护机制，使得子类只能获得访问受保护的权利。

在实际应用中，要谨慎使用 protected 属性。假设需要将设计的类提供给其他程序员使用，而在这个类中设置了一些受保护域，由于其他程序员可以由这个类再派生出新类，并访问其中的受保护域。在这种情况下，如果需要对这个类的实现进行修改，就必须通知所有使用这个类的程序员。这违背了 OOP 提倡的数据封装原则。

受保护的方法更具有实际意义。如果需要限制某个方法的使用，就可以将它声明为 protected。这表明子类（可能很熟悉祖先类）得到信任，可以正确地使用这个方法，而其他类则不行。  
这种方法的一个最好的示例就是 Object类中的 clone方法。

Java中的受保护部分对所有子类及同一个包中的所有其他类都可见。

### Java用于控制可见性的 4 个访问修饰符：
1. 仅对本类可见 —— private
1. 对所有类可见 —— public
1. 对本包和所有子类可见 —— protected
1. 对本包和所有子类可见 —— protected