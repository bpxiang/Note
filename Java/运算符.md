# 运算符

***注意：*** 整数被 0 除将会得到一个异常，而浮点数被 0 处将会得到无穷大或 NaN 结果。

***注释：*** 可移植性是 Java 语言的设计目标之一。无论在哪个虚拟机上运行，同一运算应该得到同样的结果。对于浮点数的算术运算，实现这样的可移植性是相当困难的。double 类型使用 64 位存储一个数值，而有些处理器使用 80 位浮点寄存器。这些寄存器增加了中间过程的计算精度。
```java
double w = x * y / z;
```
很多 Intel 处理器计算 x * y，并且将结果存储再 80 位的寄存器中，再除以 z 并将结果截断为 64 位。这样就可以得到一个更加精确的计算结果，并且还能够避免产生指数溢出。但是，这个结果可能与始终在 64 位机器上计算的结果不一样。因此，Java 虚拟机的最初规范规定所有的中间计算都必须进行截断。这种行为遭到了数值计算团体的反对。截断计算不仅可能导致溢出，而且由于截断操作需要消耗时间，所以在计算速度上实际上要比精确计算慢。为此，Java 程序设计语言承认了最优性能与理想结果之间存在的冲突，并给予了改进。在默认情况下，虚拟机设计者允许对中间计算结果采用扩展的精度。但是，对于使用 strictfp 关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。例如，可以把 main 方法标记为
```java
    public static strictfp void main(String[] args)
```

于是，再 main 方法中的所有指令都将使用严格的浮点计算。如果将一个类标记为 strictfp，这个类中的所有方法都要使用严格的浮点计算。

实际的计算方式将取决于 Intel 处理器的行为。在默认情况下，中间结果允许使用扩展的指数，但不允许使用扩展的尾数（Intel 芯片在截断尾数时并不损失性能）。因此，这两种方式的区别仅仅在于采用默认的方式不会产生溢出，而采用严格的计算有可能产生溢出。

## 强制类型转换

强制类型转换的语法格式是再圆括号中给想要转换的目标类型，后面紧跟待转换的变量名。

```java
double x = 9.997;
int nx = (int) x; \\ nx = 9
```
变量 nx 的值为 9。强制类型转换通过截断小数部分将浮点值转换为整数。

如果想对浮点数进行舍入运算，以便得到最近的整数（在很多情况下，这种操作更有用），那就需要使用 Math.round 方法：

```java
double x = 9.997;
int nx = (int) Math.round(x); \\ nx = 10
```

***警告：*** 如果试图将一个数值从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值。例如，(byte)300 的实际值为 44。

## 结合赋值和运算符
如果运算符得到一个值，其类型与左侧操作数的类型不同，就会发生强制类型转换。例如，如果 x 是一个 int，则以下语句
```
x += 3.5;
```
是合法的，将把 x 设置为 (int)(x + 3.5)

## 自增与自减运算符
前缀形式会先完成加 1；而后缀形式会使用变量原来的值。
```java
int m = 7;
int n = 7;
int a = 2 * ++m; // now a is 16, m is 8
int b = 2 * n++; // new b is 14, m is 8
```

建议不要在表达式中使用 ++，因为这样的代码很容让人困惑，而且会带来烦人的 bug。

## 关系和 booolean 运算符
要检测相等性，可以使用两个等号 ==，使用 != 检测不等性。

Java 经常使用<（小于）、>（大于）、<=（小于等于）和>=（大于等于）运算符。

Java 使用 `&&` 表示逻辑“与”运算符，使用`||`表示逻辑“或”运算符。感叹号 `!` 就是逻辑非运算符。`&&` 和 `||` 运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。

```
expression1 && expression2
```
计算得到第一个表达式的值为 false，那么结果就不可能为 true。因此，第二个表达式就不必计算了。可以利用这一点来避免错误。
```
x != 0 && 1 / x > x + y // no division by 0
```
如果 x 等于 0，那么第二部分就不会计算。因此，如果 x 为 0，也就不计算 1 / x，除以 0 的错误就不会出现。

如果第一个表达式为 true，`expression1 || expression2` 的值就自动为 true，而无需计算第二个表达式。

Java 支持三元操作符 `?:`，`condition ? exprestion1 : expression2` 。

## 位运算符
处理整数类型时，可以直接对组成整型数值的各个位完成操作。这意味着可以使用掩码技术得到整数中的各个位。位元算符包括：
```
&("and")    |("or")    ^("xor")    ~("not")
```
这些运算符按位模式处理。例如，如果 n 整数变量，而且用二进制表示的 n 从右边数第 4 位为 1，则
```
int fourthBitFromRight = (n & 0b1000) / 0b1000;
```
会返回 1，否则返回。利用 & 并结合使用适当的 2 的幂，可以把其他位掩饰掉，而只保留其中的某一位。

***注释：*** 应用在布尔值上时，& 和 | 运算符也会得到一个布尔值。这些元算符与 && 和 || 运算符很类似，不过 & 和 | 不采用“短路”的方式来求值，也就是说，得到计算结果之前两个操作数都按需要计算。

另外，还有 >> 和 << 元算符将位模式左移或右移。需要建立位模式来完成位掩码时，这两个元算符会很方便：
```
int fourthBitFromRight = (n & (1 << 3)) >> 3;
```

`>>>` 运算符会用 0 填充高位，这与 `>>` 不同，它会用符号位填充高位。不存在 `<<<` 运算符。

***警告:*** 位运算符的右操作数要完成模 32 的运算（除非左操作数是 long 类型，在这种情况下需要对右侧操作数模 64）。例如，`1 << 35` 的值等同于 `1 << 3` 或 `8`。

## 运算符优先级

|运算符|结合性|
|:------|:----:|
| `[].()`(方法调用) | 从左向右 |
| `!` `~` `++` `--` `+`(一元运算)`-`( 一元运算)`()`(强制类型转换)`new` | 从右向左 |
| `*` `/` `%` | 从左向右
| `+` `-` | 从左向右 |
| `<<` `>>` `>>>` | 从左向右 |
| `<` `<=` `>` `>=` `instanceof` | 从左向右 |
| `==` `!=` | 从左向右 |
| `&` | 从左向右 |
| `^` | 从左向右 |
| `|` | 从左向右 |
| `&&` | 从左向右 |
| `||` | 从左向右 |
| `?:` | 从右向左 |
| `=` `+=` `-=` `*=` `/=` `%=` `&=` `|=` `^=` `<<=` `>>=` `>>>=` | 从右向左 |
